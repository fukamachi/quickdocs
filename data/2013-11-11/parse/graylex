
(:TYPE :SYSTEM :NAME "graylex" :AUTHOR "Alexander Kahl <e-user@fsfe.org>"
 :MAINTAINER NIL :VERSION "0.0.1" :LICENCE "GPLv3+" :DESCRIPTION
 "Gray lexer input streams" :LONG-DESCRIPTION NIL :DEPENDS-ON
 ("CL-PPCRE" "TRIVIAL-GRAY-STREAMS" "ALEXANDRIA") :PACKAGE-LIST
 ((:TYPE :PACKAGE :NAME "GRAYLEX" :FULL-NAME "GRAYLEX" :DOCUMENTATION NIL
   :SYMBOL-LIST
   ((:TYPE :CLASS :SYMBOL
     (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :SUPER-CLASS-LIST
     ((:NAME "FUNDAMENTAL-CHARACTER-INPUT-STREAM" :PACKAGE-NAME
       "TRIVIAL-GRAY-STREAMS" :EXTERNALP T)
      (:NAME "TRIVIAL-GRAY-STREAM-MIXIN" :PACKAGE-NAME "TRIVIAL-GRAY-STREAMS"
       :EXTERNALP T))
     :DOCUMENTATION "Base class for buffered input streams. The default buffer
size is 1024 bytes."
     :SLOT-LIST
     ((:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) :ACCESSORS NIL
       :READERS
       ((:NAME "BUFFERED-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
       :WRITERS NIL :DOCUMENTATION
       "Wrapped input stream that is to be buffered")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "BUFFER-SIZE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL) :ACCESSORS
       ((:NAME "BUFFERED-INPUT-SIZE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
       :READERS NIL :WRITERS NIL :DOCUMENTATION "Size of the input buffer")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "BUFFER-POSITION" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       :ACCESSORS
       ((:NAME "BUFFERED-INPUT-POSITION" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
       :READERS NIL :WRITERS NIL :DOCUMENTATION
       "Reading position of the wrapped buffer")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL) :ACCESSORS
       ((:NAME "BUFFERED-INPUT-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
       :READERS NIL :WRITERS NIL :DOCUMENTATION "Wrapped input buffer")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "EOF-REACHED" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL) :ACCESSORS
       ((:NAME "BUFFERED-EOF-P" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL))
       :READERS NIL :WRITERS NIL :DOCUMENTATION
       "Whether EOF in stream has been reached")))
    (:TYPE :METHOD :SYMBOL
     (:NAME "CLOSE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ABORT" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :GENERIC :SYMBOL
     (:NAME "FLUSH-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
     :DOCUMENTATION "Flush the input buffer")
    (:TYPE :METHOD :SYMBOL
     (:NAME "FLUSH-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "flush-buffer stream => string

Return unread rest of the wrapped buffer and replenish it.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "FLUSH-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "flush-buffer stream => string

Return unread rest of the wrapped buffer and replenish it.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "INITIALIZE-INSTANCE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&REST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "INITARGS" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL))
     :DOCUMENTATION
     "initialize-instance :after stream &rest initargs => position

Create the input buffer after initialization and fill it for the first time.
Also, (re)set EOF-REACHED to NIL.")
    (:TYPE :GENERIC :SYMBOL
     (:NAME "FILL-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
     :DOCUMENTATION "Fill the input buffer")
    (:TYPE :METHOD :SYMBOL
     (:NAME "FILL-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "fill-buffer stream => position

Fill the input buffer by reading from the wrapped stream. Also reset the reading
position to zero.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "FILL-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "fill-buffer stream => position

Fill the input buffer by reading from the wrapped stream. Also reset the reading
position to zero.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-CHAR" :PACKAGE-NAME "SB-GRAY" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "stream-read-char :before stream => position

If reading beyond the internal buffer, replenish it.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-CHAR" :PACKAGE-NAME "SB-GRAY" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "stream-read-char stream => char or :eof

Return next character from wrapped input buffer or :EOF if the end of the input
stream is reached.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-UNREAD-CHAR" :PACKAGE-NAME "SB-GRAY" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "CHAR" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION "stream-unread-char stream char => error

Unreading chars is not supported for BUFFERED-INPUT-STREAMS.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-SEQUENCE" :PACKAGE-NAME "TRIVIAL-GRAY-STREAMS"
      :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "SEQ" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
      (:NAME "START" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
      (:NAME "END" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION "stream-read-sequence stream seq start end &key => position

Apply READ-SEQUENCE to given arguments and the wrapped input stream. All
mechanisms of BUFFERED-INPUT-STREAM apply.
Please see READ-SEQUENCE's documentation.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "EOF-WATCHDOG-FILTER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRING" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION
     "eof-watchdog-filter string stream => lambda position => position

To be used as a CL-PPCRE filter; evaluates to function that
takes one argument POSITION and signals LEXING-BUFFER-EOF if end of STRING to
scan is reached and no more input is to come from STREAM.")
    (:TYPE :CLASS :SYMBOL
     (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :SUPER-CLASS-LIST
     ((:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
     :DOCUMENTATION "Lexer input streams provide lexical analysis, tracking of
input row and column and a dynamic second buffer for input tokens longer than
the primary BUFFERED-INPUT-STREAM buffer size."
     :SLOT-LIST
     ((:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "RULES" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL) :ACCESSORS
       ((:NAME "LEXER-RULES" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)) :READERS
       NIL :WRITERS NIL :DOCUMENTATION "List of regexp/keyword conses")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "ROW" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL) :ACCESSORS
       ((:NAME "LEXER-ROW" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)) :READERS NIL
       :WRITERS NIL :DOCUMENTATION "Current row in lexer stream")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "COLUMN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL) :ACCESSORS
       ((:NAME "LEXER-COLUMN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)) :READERS
       NIL :WRITERS NIL :DOCUMENTATION "Current column in lexer stream")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "NON-STREAM-POSITION" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       :ACCESSORS
       ((:NAME "LEXER-NON-STREAM-POSITION" :PACKAGE-NAME "GRAYLEX" :EXTERNALP
         T))
       :READERS NIL :WRITERS NIL :DOCUMENTATION "Position in unread sequence")
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "DOUBLE-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       :ACCESSORS
       ((:NAME "LEXER-DOUBLE-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
       :READERS NIL :WRITERS NIL :DOCUMENTATION "Double buffer")))
    (:TYPE :METHOD :SYMBOL
     (:NAME "INITIALIZE-INSTANCE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&REST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "INITARGS" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL))
     :DOCUMENTATION
     "initialize-instance :after stream &rest initargs => position

Create the double buffer after initialization.")
    (:TYPE :GENERIC :SYMBOL
     (:NAME "LEXER-UNREAD-SEQUENCE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
      (:NAME "SEQ" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL))
     :DOCUMENTATION "Unread a sequence by feeding it into the double buffer")
    (:TYPE :METHOD :SYMBOL
     (:NAME "LEXER-UNREAD-SEQUENCE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "SEQ" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL))
     :DOCUMENTATION "lexer-unread-sequence stream seq => position

Prepend sequence SEQ to the internal double buffer and increase the non-stream
position.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "LEXER-UNREAD-SEQUENCE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "SEQ" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL))
     :DOCUMENTATION "lexer-unread-sequence stream seq => position

Prepend sequence SEQ to the internal double buffer and increase the non-stream
position.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "FLUSH-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "flush-buffer stream => string

Return unread rest of the wrapped main buffer but also append it to the double
buffer.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-CHAR" :PACKAGE-NAME "SB-GRAY" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))
     :DOCUMENTATION "stream-read-char stream => char or :eof

Also save read characters into the double buffer.")
    (:TYPE :GENERIC :SYMBOL
     (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
      (:NAME "&OPTIONAL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "PEEK" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL))
     :DOCUMENTATION "Read lexical tokens from the input stream")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&OPTIONAL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "PEEK" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "stream-read-token stream &optional peek => (class image)

Scan the lexer's double buffer successively with all its rules. Rules are
expected to be conses of PCRE-compatible regular expressions and class name
keywords. Heads-up: Every rule get prepended with an implicit start 
anchor (\"^\") to match the beginning of the buffer!

If the double buffer is empty, simply return NIL; is no rule matches, signal an
UNMATCHED-LEXING-SEQUENCE with further details and provide the following
restarts:
- flush-buffer: Call the method of the same name and try to scan again
- skip-characters count: Skip COUNT characters of the reported sequence and try
  to scan again

Be sure to *not* use any of these unconditionally, you'll end up with an
infinite loop! Instead, apply UNMATCHED-SEQUENCE to the condition in your
handler to investigate and act accordingly; e.g. a hypothetical lexer rule could
require at least five characters to match but the unmatched sequence has only
three so reasonable handling code could look like this:
> (handler-bind ((unmatched-lexing-sequence #'(lambda (condition)
                                                (if (< (length (unmatched-sequence condition)) 5)
                                                    (invoke-restart 'flush-buffer)
                                                  (error condition)))))
    (function-that-invokes-stream-read-token))")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&OPTIONAL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "PEEK" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "stream-read-token stream &optional peek => (class image)

Scan the lexer's double buffer successively with all its rules. Rules are
expected to be conses of PCRE-compatible regular expressions and class name
keywords. Heads-up: Every rule get prepended with an implicit start 
anchor (\"^\") to match the beginning of the buffer!

If the double buffer is empty, simply return NIL; is no rule matches, signal an
UNMATCHED-LEXING-SEQUENCE with further details and provide the following
restarts:
- flush-buffer: Call the method of the same name and try to scan again
- skip-characters count: Skip COUNT characters of the reported sequence and try
  to scan again

Be sure to *not* use any of these unconditionally, you'll end up with an
infinite loop! Instead, apply UNMATCHED-SEQUENCE to the condition in your
handler to investigate and act accordingly; e.g. a hypothetical lexer rule could
require at least five characters to match but the unmatched sequence has only
three so reasonable handling code could look like this:
> (handler-bind ((unmatched-lexing-sequence #'(lambda (condition)
                                                (if (< (length (unmatched-sequence condition)) 5)
                                                    (invoke-restart 'flush-buffer)
                                                  (error condition)))))
    (function-that-invokes-stream-read-token))")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&OPTIONAL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "PEEK" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "stream-read-token :around stream &optional peek => (class image)

Scan the result from calling the next method if PEEK is NIL:
Discard the matched part from the beginning of the double buffer and either just
decrease the non-stream position or record the column and row progress.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&OPTIONAL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "PEEK" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "stream-read-token :around stream &optional peek => (class image)

Scan the result from calling the next method if PEEK is NIL:
Discard the matched part from the beginning of the double buffer and either just
decrease the non-stream position or record the column and row progress.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&OPTIONAL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "PEEK" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "stream-read-token :before stream &optional peek => string

If the internal double buffer is empty, flush the main buffer first in order to
replenish it.")
    (:TYPE :METHOD :SYMBOL
     (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
     :LAMBDA-LIST
     (((:NAME "STREAM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T))
      (:NAME "&OPTIONAL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "PEEK" :PACKAGE-NAME "GRAYLEX" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "stream-read-token :before stream &optional peek => string

If the internal double buffer is empty, flush the main buffer first in order to
replenish it."))
   :EXTERNAL-SYMBOLS
   ((:NAME "LEXER-NON-STREAM-POSITION" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "STREAM-READ-TOKEN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "BUFFERED-INPUT-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "UNMATCHED-SEQUENCE-COLUMN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "LEXER-DOUBLE-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "STREAM-READ-SEQUENCE" :PACKAGE-NAME "TRIVIAL-GRAY-STREAMS"
     :EXTERNALP T)
    (:NAME "FILL-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "UNMATCHED-SEQUENCE-ROW" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "STREAM-READ-CHAR" :PACKAGE-NAME "SB-GRAY" :EXTERNALP T)
    (:NAME "BUFFERED-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "BUFFERED-INPUT-SIZE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "BUFFERED-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "LEXER-ROW" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "LEXER-INPUT-STREAM" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "BUFFERED-INPUT-POSITION" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "LEXER-UNREAD-SEQUENCE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "FLUSH-BUFFER" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "LEXER-COLUMN" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "LEXER-RULES" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "UNMATCHED-SEQUENCE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)
    (:NAME "UNMATCHED-LEXING-SEQUENCE" :PACKAGE-NAME "GRAYLEX" :EXTERNALP T)))))
