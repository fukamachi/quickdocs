
(:TYPE :SYSTEM :NAME "spartns" :AUTHOR "Jeronimo Pellegrini" :MAINTAINER
 "Jeronimo Pellegrini" :VERSION "1.4.3" :LICENCE "LLGPL" :DESCRIPTION
 "SPARse TeNSor representation library" :LONG-DESCRIPTION NIL :DEPENDS-ON NIL
 :PACKAGE-LIST
 ((:TYPE :PACKAGE :NAME "JP-UTILS" :FULL-NAME "JP-UTILS" :DOCUMENTATION NIL
   :SYMBOL-LIST
   ((:TYPE :MACRO :SYMBOL
     (:NAME "WITH-GENSYMS" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "&REST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "NAMES" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
      (:NAME "&BODY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "BODY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Expands into code that binds all names to symbols generated by (gensym).")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "BINARY-SEARCH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "THE-ELEMENT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "VECTOR" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "TEST=" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "FUNCTION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "EQL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "TEST<" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "FUNCTION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "<" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "GET-ELEMENT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "FUNCTION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "AREF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "START" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) 0)
      ((:NAME "END" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "1-" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "LENGTH" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         (:NAME "VECTOR" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))))
      ((:NAME "NOT-FOUND" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "Performs a binary search for an element el on a (sorted) array vec.
Return values:
   - The index where the element was found
   - Either t (if el was found) or nil (if el was not found) You can ask
     the function to return something else on failure.
Named parameters:
   - get-element is the function used to retrieve an element of the vector.
     The default is aref. This should be a FUNCTION, and not a symbol!
   - start and end are the start and end indices within the array. If
     they are not supplied, 0 and the last index will be used.
   - test= and test-before are the tests to be used for equality and for
     determining precedence between elements. These should be FUNCTIONS,
     and not symbols!
   - not-found is the element to be returned when the element is not found.
     If not-found is set to 't', then, in case of failure, the function will
     return (i NIL), where i is the index where the element *should* be (or
     where it could be inserted).
     So, by default you can test the return inside an (if (binary-search) ...),
     since it returns either NIL or the position.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "FAST-BINARY-SEARCH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "THE-ELEMENT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "VECTOR" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "ELEMENT-TYPE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       (:NAME "T" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      ((:NAME "TEST=" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "EQL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "TEST<" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "<" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "GET-ELEMENT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "AREF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "START" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) 0)
      ((:NAME "END" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      ((:NAME "NOT-FOUND" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "This is binary search with type declarations. It's similar to the binary-search function.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "GET-BINARY-SEARCH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "ELEMENT-TYPE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       (:NAME "T" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      ((:NAME "TEST=" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "EQL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "TEST<" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "<" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "GET-ELEMENT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "AREF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "NOT-FOUND" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))))
     :DOCUMENTATION
     "This function returns a function (with type declarations) that will perform binary search.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "HASH-TABLE-KEYS" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
     :LAMBDA-LIST ((:NAME "HASH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION "Returns a list with the keys of a hash table.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "HASH-TABLE-KEYS-AS-ARRAY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
     :LAMBDA-LIST ((:NAME "HASH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "GENERATE-RANDOM-ARRAY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "SIZE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "RANGE-START" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "RANGE-END" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Generates an array of fixnums of size n, ranging from 0 to k")
    (:TYPE :MACRO :SYMBOL
     (:NAME "DO-SEQUENCE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T) :LAMBDA-LIST
     (((:NAME "IDX" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       (:NAME "SEQ" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
      (:NAME "&REST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "BODY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION "Runs across a sequence (syntatic sugar).")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "SEQUENCE-FIRST" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
     :LAMBDA-LIST ((:NAME "SEQ" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION "Returns the first element of a sequence.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "SORTEDP" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "SEQ" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "TEST" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "FUNCTION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "<" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))))
     :DOCUMENTATION "Determines if a sequence is sorted. Will return (t size)
 on success (where size is the size of the sequence) or
nil size), where size is the size of the largest sorted subsequence,
from the beginning to the right.
For example:
 (sortedp '(10 20 30 40 1 100)) ==> (NIL, 4)
 (sortedp #(10 20 30 40 50 100)) ==> (T, 6)
See that the size of the sorted sequence is always at least one, except
for empty sequences, which are always sorted:
 (sortedp ()) ==> (T, 0)
")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "COUNTING-SORT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "DATA" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "K" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "START" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) 0)
      ((:NAME "END" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) -1))
     :DOCUMENTATION "Counting sort. Only works for arrays of fixnums.
data is the array. The elements in the array must range from
zero to k. Optional parameters start and end can be used to specify
a subrange of the array to be sorted, but then the new array will
have zeroes in all other places (this will be fixed later).

This function returns the new array and the counting array, which
tells where each each key starts in the new array.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "COUNTING-SORT-G" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "DATA" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "SORTED-DATA" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "K" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "START" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "END" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "KEY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "FUNCTION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "AREF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "COPY-ELEMENT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "FUNCTION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "LAMBDA" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "NEW" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
          (:NAME "NEW-I" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
          (:NAME "OLD" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
          (:NAME "OLD-I" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
         ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
          ((:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
           ((:NAME "SIMPLE-ARRAY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
            (:NAME "FIXNUM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
            ((:NAME "*" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
           (:NAME "OLD" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
           (:NAME "NEW" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
          ((:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
           (:NAME "FIXNUM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
           (:NAME "OLD-I" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
           (:NAME "NEW-I" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)))
         ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
          ((:NAME "AREF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
           (:NAME "NEW" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
           (:NAME "NEW-I" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
          ((:NAME "AREF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
           (:NAME "OLD" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
           (:NAME "OLD-I" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)))))))
     :DOCUMENTATION
     "Generalized counting sort: it will sort data structures, provided that there
is a way to identify elements with fixnum keys.

Parameters:
===========
- data is the structure to be sorted.
- sorted-data is the new sorted structure, that needs to be previously allocated
  (and be similar to data)
- k is the maximum key value. CAUTION: this function will allocate an array
  of size k, so if it is too large, it may not work.
- start and end define the slice of the keys that will be sorted.
- The key function identifies array elements given a fixnum. By default
  tihs is aref;
- The copy-element wihch will be used to copy elements among different posisions
  needs to have four arguments:
  +  new:   the new data structure
  +  new-i: the index in the new data structure
  +  old:   the old data structure
  +  old-i: the index in the old data structure
  So, given those, this function should copy an element from position old-i on
  structure old to position new-i on structure new.

Return value and result:
========================

This function will return the counting array, which shows where in the new structure
each key begins:

 (let ((new-data (make-array 12 :element-type 'fixnum)))
   (counting-sort-g #(0 2 4 6 0 2 4 6 1 3 5 7) new-data 8 0 11))
  => #(0 2 3 5 6 8 9 11)

new-data      #(0 0 1 2 2 3 4 4 5 6 6 7)
count vector: #(0 2 3 5 6 8 9 11)

Looking at the count vector, we see that the elements with key '0' start
at position '0' in the new structure; the elements with key '1' start
at position '2'; elements with key '2' start at '3', etc, and elements
with key '7' start at the last position, '11'.

Example:
========
 ;;; A structure contains two arrays:
 (defstruct (two-arrays (conc-name ta))
   array-one
   array-two)

 ;;; Now we sort it, using the first array as the key array, and the second as
 ;;; the data array.
 (counting-sort-g two-arrays
                  two-arrays-new
                  100
                  10
                  110
                  :key          #'(lambda (data i) (aref (ta-array-one data) i))
                  :copy-element #'(lambda (new new-i old old-i)
                                   (setf (aref (ta-array-one new) new-i) (aref (ta-array-one old) old-i)
                                         (aref (ta-array-two new) new-i) (aref (ta-array-two old) old-i))

Efficiency:
===========

If k is not large, this is much faster than Lisp's built-in sort function, because it
does not rely on element comparison. cl:sort takes O(n lg n) time, counting-sort-g takes
O(n + k) time. On the other hand, it requires O(n + k) additional memory: besides the
argument sorted-data, which is provided by you, this function will also allocate an array
of size k.

For details, see:

- Cormen, Leiserson, Rivest and Stein: 'Introduction to algorithms'
- Berman and Paul, 'Algorithms: sequential, parallel, and distributed'
- Wikipedia:
  + http://en.wikipedia.org/wiki/Sorting_algorithm
  + http://en.wikipedia.org/wiki/Counting_sort

Because it is generic and works on any data structure, this function can be ten times
slower than the counting-sort function in this package, which works on arrays of fixnums
only.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "SUBST-ALL" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "SUBST-LIST" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "TREE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Performs several substitutions on a tree (similar to what subst does).
subst-list is a list of substitutions. For example:
 (subst-all '((a 1) (b 2) (c 3))
            '(x y a (z b (u v c))))
  => (X Y 1 (Z 2 (U V 3)))")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "FORMAT-SYMBOL" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "STRING" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "&REST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ARGS" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "FORMAT-UNINTERNED-SYMBOL" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "STRING" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "&REST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ARGS" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "ROBUST-ADJUST-ARRAY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "ARRAY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SIZE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "ELEMENT-TYPE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "Adjusts the size of an array, setting it to the new one. Also works around
an issue with Allegro Common Lisp: in ACL, when you call adjust-array on a non-adjustable
array, the resulting array is not necessarily of the same type. It is not a SIMPLE-ARRAY
anymore.  Dependig on how you try to fix it, you may end up with an array whose
element-type is T. So, this is a method for resizing an array and keeping the same array
type.

Yes, we want SIMPLE-ARRAYs because access is faster. But we also want to adjust them, even
if adjusting is slow.")
    (:TYPE :TYPE :SYMBOL
     (:NAME "INTERNAL-TIME-TYPE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
     :LAMBDA-LIST (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
     :DOCUMENTATION NIL)
    (:TYPE :STRUCT :SYMBOL
     (:NAME "CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) :SUPER-CLASS-LIST
     NIL :DOCUMENTATION NIL :SLOT-LIST NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CLOCK-START-TIME" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "CLOCK-START-TIME" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CLOCK-ELAPSED-TIME" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "CLOCK-ELAPSED-TIME" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CLOCK-RUNNING" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "CLOCK-RUNNING" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "MAKE-CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (((:NAME "START-TIME" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM966" :PACKAGE-NAME NIL :EXTERNALP NIL))
       0)
      (((:NAME "ELAPSED-TIME" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM967" :PACKAGE-NAME NIL :EXTERNALP NIL))
       0)
      (((:NAME "RUNNING" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM968" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "RESET-CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)) :DOCUMENTATION
     "Completely resets the stopwatch.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "START-CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)) :DOCUMENTATION
     "Sets the start time of the stopwatch to 'now',
but does NOT reset the elapsed time.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "STOP-CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)) :DOCUMENTATION
     "Pauses the stopwatch and updates the elapsed-time.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "ELAPSED-TIME" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "CLOCK" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "AS" :PACKAGE-NAME "JP-UTILS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "SINGLE-FLOAT" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))))
     :DOCUMENTATION "Returns the time elapsed since the stopwatch started,
while it was running (pauses are excluded).
If the clock was currently running, the time until now
is computed. Otherwise, time until the most recenr stop
is computed."))
   :EXTERNAL-SYMBOLS
   ((:NAME "GET-MAP" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "SET-MAP" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "SUBST-ALL" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "WITH-GENSYMS" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "FORMAT-UNINTERNED-SYMBOL" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "COUNTING-SORT-G" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "GENERATE-RANDOM-ARRAY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "FORMAT-SYMBOL" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "SORTEDP" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "ROBUST-ADJUST-ARRAY" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "DO-SEQUENCE" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "GET-BINARY-SEARCH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "COUNTING-SORT" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "HASH-TABLE-KEYS" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "FAST-BINARY-SEARCH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)
    (:NAME "BINARY-SEARCH" :PACKAGE-NAME "JP-UTILS" :EXTERNALP T)))
  (:TYPE :PACKAGE :NAME "SPARTNS" :FULL-NAME "SPARTNS" :DOCUMENTATION NIL
   :SYMBOL-LIST
   ((:TYPE :VARIABLE :SYMBOL
     (:NAME "*REPRESENTATION-SCHEMES*" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :DOCUMENTATION "This variable holds a hashtable that maps names (symbols)
to representation schemes for sparse vectors. These are structures
that map fixnums onto data of any type."
     :INITIAL-VALUE "(MAKE-HASH-TABLE :SIZE 20 :TEST 'EQ)")
    (:TYPE :VARIABLE :SYMBOL
     (:NAME "*SPARTN-SCHEMES*" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :DOCUMENTATION
     "This variable holds a hashtable which maps names onto spartn schemes. "
     :INITIAL-VALUE "(MAKE-HASH-TABLE)")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "GET-SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)) :DOCUMENTATION
     "Retrieves a representation scheme given its name, which should be a symbol. If the scheme
is not registered, this function returns NIL.

 (spartns::get-scheme 'spartns:cvector)
 ==>
  #<HASH-TABLE :TEST EQ :COUNT 10 {10036CF001}>
  T

The hashtable returned is the representation scheme (see the function DEFSCHEME).")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "REMOVE-SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST ((:NAME "NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Removes a representation scheme from the database.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "EXPAND-SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "FUNCTION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SUBST-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Expands the code from a representation scheme, substituting parameters.
For example, if a scheme with the name 'cvector has this function registered:
'spartns::get --> '(get-cvec data index sparse-element)
Then expand-scheme will work like this:
 (expand-scheme 'spartns::get 'cvector '((data d) (index i) (sparse-element sp)))
  => '(get-cvec d i sp)")
    (:TYPE :MACRO :SYMBOL
     (:NAME "DEFSCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "MAKE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "GET" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SET" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "DELETE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "TRAVERSE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "PACK" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "CAPACITY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "COUNT" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION "Adds a new representation scheme.
- name is the name of the scheme (a symbol)
- type is the Common Lisp type of an instance of this scheme. For example, if your scheme
  represents the mapping as a hashtable, then type is HASH-TABLE. If it is represented as a
  Lisp list, then it is LIST

All other parameters (make, get, set, delete, traverse, capacity, count) should contain the
Lisp code necessary to perform these actions:

- make: the code necessary to create an instance of this scheme. If your code contains the
  symbols SIZE and ELEMENT-TYPE, they will be substituted for the actual values;
- get: code necessary to access one element. Symbols that are substituted: DATA, INDEX,
  SPARSE-ELEMENT. It should return TWO VALUES:
  + the retrieved element (the sparse element, if the index was not found);
  + either T or NIL, depending on wether the element was found or not.
  For example, (IF found (VALUES element T)
                         (VALUES sparse NIL));
- set: code to set one position. Substituted symbols: DATA, INDEX, VALUE, ELEMENT-TYPE
- delete: code to remove one element. Substituted symbols: DATA, INDEX, SPARSE-ELEMENT,
  ELEMENT-TYPE;
- traverse: code to traverse the structure, binding variables to the index and value while
  executing a body of code. Substituted symbols: INDEX, VALUE, DATA, ELEMENT-TYPE, BODY;
- pack: code that packs the container, releasing non-used memory;
- capacity: code that returns the maximum number of elements that the instance can handle.
  Substituted symbols: DATA;
- count: code to return the actual number of non-zero elements. Substituted symbols: DATA.

The macro will return the name of the newly created scheme.

For example:
 (defscheme :name     hash
            :type     HASH-TABLE
            :make     (let () (declare (ignore element-type)) (make-hash-table :size size))
            :get      (gethash index data sparse-element)
            :set      (setf (gethash index data) value)
            :delete   (remhash index data)
            :traverse (do-traverse-hash (index value data) body)
            :pack     (values) ; we don't write code for shrinking a hashtable!
            :capacity (let () (declare (ignore data)) most-positive-fixnum)
            :count    (hash-table-count data))

In the example, the make function ignores ELEMENT-TYPE (because hashtables ignore them).

However, you should NOT try to make the code ignore symbols by using, for example,
 (let () (declare (ignore element-type)) (make-hash-table :size size))
because the element-type inside DECLARE will be substituted.

Since the make function returns an object of type HASH-TABLE, then this is the value passed to
the type parameter.

The capacity code always returns most-positive-fixnum, since hashtables can grow.")
    (:TYPE :STRUCT :SYMBOL
     (:NAME "ARRAY-STRUCTURE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :SUPER-CLASS-LIST NIL :DOCUMENTATION NIL :SLOT-LIST NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "ARRAY-STRUCTURE-VALUES" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ARRAY-STRUCTURE-VALUES" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "ARRAY-STRUCTURE-ACTIVE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ARRAY-STRUCTURE-ACTIVE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "ARRAY-STRUCTURE-MAX-CAPACITY" :PACKAGE-NAME "SPARTNS" :EXTERNALP
      NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ARRAY-STRUCTURE-MAX-CAPACITY" :PACKAGE-NAME "SPARTNS" :EXTERNALP
       NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "ARRAY-STRUCTURE-COUNT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ARRAY-STRUCTURE-COUNT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "MAKE-ARRAY-STRUCTURE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (((:NAME "VALUES" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM199" :PACKAGE-NAME NIL :EXTERNALP NIL))
       ((:NAME "MAKE-ARRAY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 0))
      (((:NAME "ACTIVE" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM200" :PACKAGE-NAME NIL :EXTERNALP NIL))
       ((:NAME "MAKE-ARRAY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 0
        (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "MOD" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 2))))
      (((:NAME "MAX-CAPACITY" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM201" :PACKAGE-NAME NIL :EXTERNALP NIL))
       0)
      (((:NAME "COUNT" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM202" :PACKAGE-NAME NIL :EXTERNALP NIL))
       0))
     :DOCUMENTATION NIL)
    (:TYPE :STRUCT :SYMBOL
     (:NAME "CVECTOR" :PACKAGE-NAME "SPARTNS" :EXTERNALP T) :SUPER-CLASS-LIST
     NIL :DOCUMENTATION NIL :SLOT-LIST NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CVECTOR-VALUES" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "CVECTOR-VALUES" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CVECTOR-INDEX" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "CVECTOR-INDEX" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CVECTOR-MAX-CAPACITY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "CVECTOR-MAX-CAPACITY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CVECTOR-COUNT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "CVECTOR-COUNT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :LAMBDA-LIST
     ((:NAME "NEW-VALUE" :PACKAGE-NAME "SB-KERNEL" :EXTERNALP NIL)
      (:NAME "STRUCTURE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "MAKE-CVECTOR" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (((:NAME "VALUES" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM411" :PACKAGE-NAME NIL :EXTERNALP NIL))
       ((:NAME "MAKE-ARRAY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 0))
      (((:NAME "INDEX" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM412" :PACKAGE-NAME NIL :EXTERNALP NIL))
       ((:NAME "MAKE-ARRAY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 0
        (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         (:NAME "FIXNUM" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))))
      (((:NAME "MAX-CAPACITY" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM413" :PACKAGE-NAME NIL :EXTERNALP NIL))
       0)
      (((:NAME "COUNT" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM414" :PACKAGE-NAME NIL :EXTERNALP NIL))
       0))
     :DOCUMENTATION NIL)
    (:TYPE :MACRO :SYMBOL
     (:NAME "MAKE-NEW-CVECTOR" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "SIZE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "T" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      ((:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) 0))
     :DOCUMENTATION
     "Makes a new (empty) cvector with maximum capacity equal to size.
The element-type parameter can be used to make the internal representation more efficient.
The default element-type is T.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "GET-CVEC" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "CV" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Retrieves an element from a cvector, given its index.
If the element is found, returns (values element T).
If the element is not in the vector, returns (values sparse-element NIL) instead.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "RESIZE-CVEC" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "CV" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NEW-SIZE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Resizes a cvector, adjusting the arrays for values and indices")
    (:TYPE :MACRO :SYMBOL
     (:NAME "PACK-CVEC" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "CV" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Packs a cvector so cvector-count will be the same as cvector-max-capacity.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "SET-CVEC" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "CV" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "VALUE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Sets an element in a cvector, given its index.
If the index is not in the vector, it is added, unless there is no more space left,
in which case an error is signaled.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "DO-TRAVERSE-CVECTOR" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     (((:NAME "INDEX" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "VALUE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "CVEC" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       ((:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
        (:NAME "T" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
       ((:NAME "START" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) 0)
       ((:NAME "END" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) -1)
       ((:NAME "SETF" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "T" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      (:NAME "&BODY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Traverses a cvector, binding variables to the index and value.

element-type is used in type declarations inside the code; start and end are used
for indices; setf is a flag that makes the method use SYMBOL-MACROLET instead of
LET for the value binding (it is on by default).

Example:
 (macroexpand-1 '(spartns::do-traverse-cvector (i v d) b))

 ==>

 (LET ((#:FIXED-END-775 (1- (SPARTNS::CVECTOR-COUNT D))))
   (LOOP SPARTNS::FOR #:I-774 FIXNUM SPARTNS::FROM 0 SPARTNS::TO
         #:FIXED-END-775 DO
         (LET ((I (AREF (SPARTNS::CVECTOR-INDEX D) #:I-774)))
           (SYMBOL-MACROLET ((V
                              (AREF
                               (THE (SIMPLE-ARRAY T (*))
                                    (SPARTNS::CVECTOR-VALUES D))
                               #:I-774)))
             (DECLARE (TYPE T V) (TYPE FIXNUM I))
             B))))
 T")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "SPARSE-ELEMENT-FOR-NEXT-DIM" :PACKAGE-NAME "SPARTNS" :EXTERNALP
      NIL)
     :LAMBDA-LIST
     ((:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Returns the sparse element to be used in the next dimension: either the
sparse-element for the tensor (if this is the last dimension) or an empty
map using next dimension's representation.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CHAINED-MAKE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NON-ZERO-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "This function will return the code necessary to create the representation of one
of the dimensions of the sparse tensor.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CHAINED-PACK" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CHAINED-GET" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "BLOCK-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "This function will return the code necessary to access one element in
a sparse tensor, given the chained representation scheme.
- data will be inserted as is in the code. It is the container where the tensor is stored.
- rep-list MUST be a list of the representation schemes, and it CANNOT be a variable,
           because it will be used in macroexpansion time.
- index-list is inserted as is, and will be later replaced by the list of indices.
- element-type is inserted as is. It is the type of the stored elements.
- sparse-element is inserted as is. It is the value of the sparse element.
- block-name is just a name for the block of code. A wrapper function will use gensym
  for this.
This function should be used by a macro that creates the real function for accessing the
tensor.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CREATE-NEXT-DIM" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "VALUE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NON-ZERO-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "This function is used by chained-set to create a new structure when necessary.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CHAINED-SET" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NEW-VALUE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NON-ZERO-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "BLOCK-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "This function will return the code necessary to store one element in
a sparse tensor, given the chained representation scheme.
- data will be inserted as is in the code. It is the container where the tensor is stored.
- rep-list MUST be a list of the representation schemes, and it CANNOT be a variable,
           because it will be used in macroexpansion time.
- index-list is inserted as is, and will be later replaced by the list of indices.
- new-value will be inserted as is. It is the value to be stored in the tensor.
- element-type is inserted as is. It is the type of the stored elements.
- sparse-element is inserted as is. It is the value of the sparse element.
- block-name is just a name for the block of code. A wrapper function will use gensym
  for this.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CHAINED-DELETE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "BLOCK-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "This function will return the code necessary to delete one element from
a sparse tensor, given the chained representation scheme.
- data will be inserted as is in the code. It is the container where the tensor is stored.
- rep-list MUST be a list of the representation schemes, and it CANNOT be a variable,
           because it will be used in macroexpansion time.
- index-list is inserted as is, and will be later replaced by the list of indices.
- element-type is inserted as is. It is the type of the stored elements.
- sparse-element is inserted as is. It is the value of the sparse element.
- block-name is just a name for the block of code. A wrapper function will use gensym
  for this.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "TRAVERSE-SPARTN-AUX" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "INDEX-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "VALUE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DONT-BIND" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "This is an auxiliary function that is used by the spartn-generic-traverse macro.
It will produce the code to traverse a sparse tensor, given the representation
scheme.

dont-bind is a list of indices not to bind.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "SPARTN-GENERIC-TRAVERSE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     (((:NAME "INDEX-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "VALUE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DONT-BIND" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&BODY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Traverses a sparse tensor, given:
- A list of symbols (that will be bound to the indices)
- A symbol to be bound to the value
- The data
- The representation scheme
- The body")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEF-SPARTN-GET" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "FUN-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "OPTIMIZE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "SPEED" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 3)
         ((:NAME "SAFETY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 1))))
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "Creates a function to get elements in a tensor.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEF-SPARTN-PACK" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "FUN-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "Creates a function that packs a sparse tensor.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEF-SPARTN-SET" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "FUN-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NON-ZERO-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "OPTIMIZE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "SPEED" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 3)
         ((:NAME "SAFETY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 1))))
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "Creates a function to set elements in a tensor.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEF-SPARTN-DELETE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "FUN-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "OPTIMIZE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "SPEED" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 3)
         ((:NAME "SAFETY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 1))))
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "Creates a function to delete elements from a tensor.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEF-SPARTN-MAKE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "FUN-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SPARSE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NON-ZERO-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "OPTIMIZE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "SPEED" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 3)
         ((:NAME "SAFETY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 1))))
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "Creates a function to initialize a tensor.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEF-SPARTN-TRAVERSE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "MAC-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "SPARSE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "Creates a macro for traversing one type of spartn, given the representation scheme (as a list), the element
type, the sparse element and the desired name for the new macro.
For example:
 (def-spartn-traverse do-hhd (hash hash) double-float 0d0 #'=)
This will create a macro DO-HHD which can be used like this:
 (do-hhd ((i j) val data)
   (format t \"The value at (~a, ~a) is ~a\" i j val))")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEF-SPARTN-COPY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "FUN-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SCHEME-NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "OPTIMIZE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "SPEED" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 3)
         ((:NAME "SAFETY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) 1))))
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "Creates a fuction that copies a spartn.

Examples:

 (def-spartn-copy 'my-copy-function 'hash)
 ==>
 (MY-COPY-FUNCTION (#:DATA-817) \"Copies a sparse tensor of type HASH\"
   (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 1)))
   (SPARTN-CONVERT #:DATA-817 :FROM HASH :TO HASH :DESTRUCTIVE NIL))

 (def-spartn-copy 'my-copy-function 'hash :def t)
 ==>
  (DEFUN MY-COPY-FUNCTION (#:DATA-820)
     \"Copies a sparse tensor of type HASH\"
     (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 1)))
     (SPARTN-CONVERT #:DATA-820 :FROM HASH :TO HASH :DESTRUCTIVE NIL))")
    (:TYPE :STRUCT :SYMBOL
     (:NAME "SPARTN-SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :SUPER-CLASS-LIST
     ((:NAME "STRUCTURE-OBJECT" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION NIL :SLOT-LIST
     ((:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "REPRESENTATION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       :ACCESSORS NIL :READERS NIL :WRITERS NIL :DOCUMENTATION NIL)
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "NON-ZERO" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :ACCESSORS NIL
       :READERS NIL :WRITERS NIL :DOCUMENTATION NIL)
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :ACCESSORS
       NIL :READERS NIL :WRITERS NIL :DOCUMENTATION NIL)
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       :ACCESSORS NIL :READERS NIL :WRITERS NIL :DOCUMENTATION NIL)
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T) :ACCESSORS
       NIL :READERS NIL :WRITERS NIL :DOCUMENTATION NIL)
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :ACCESSORS
       NIL :READERS NIL :WRITERS NIL :DOCUMENTATION NIL)
      (:TYPE :CLASS-SLOT :SYMBOL
       (:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       :ACCESSORS NIL :READERS NIL :WRITERS NIL :DOCUMENTATION NIL)))
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "MAKE-SPARTN-SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (((:NAME "REPRESENTATION" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM2761" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      (((:NAME "NON-ZERO" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM2762" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      (((:NAME "ELEMENT-TYPE" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM2763" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      (((:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM2764" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      (((:NAME "DECLARE" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM2765" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      (((:NAME "TEST-EQUAL" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM2766" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      (((:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "KEYWORD" :EXTERNALP T)
        (:NAME "DUM2767" :PACKAGE-NAME NIL :EXTERNALP NIL))
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION NIL)
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEFINE-SPARTN-FUNCTIONS" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARTN-SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-DEFS" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "Returns the code for the functions used with a spartn scheme. This is used by defspartn and w/spartns.
If DEF is T, then this function will generate top-level code to define the functions:

 (DEFUN get-X (tensor index) ...)

If DEF is NIL, then only the names, lambda-lists and bodies are generated:

 (get-X (tensor index) ...)

The first form is used by defspartn (which is supposed to be used as a top-leval form), and the second
is used by w/spartns (which will use LABELS to create local functions).")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DEFINE-SPARTN-MACROS" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARTN-SCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "EMPTY-DIM-MAP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "Returns the code for the macros used with a spartn scheme. This is used by defspartn and w/spartns.
If DEF is T, then this function will generate top-level code to define the functions and macros:

 (DEFMACRO traverse-X (index-list value tensor &body body) ...)

If DEF is NIL, then only the names, lambda-lists and bodies are generated:

 (traverse-X (index-list value tensor &body body) ...)

The first form is used by defspartn (which is supposed to be used as a top-leval form), and the second
is used by w/spartns (which will use MACROLET to create local macros).")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "GET-CREATE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "REP" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)) :DOCUMENTATION
     "Returns the Lisp code to create an empty dimension, given its representation.
Examples:

 (get-create 'hash)
 ==>
   (MAKE-HASH-TABLE :SIZE 0)

 (get-create 'cvector)
 ==>
   (MAKE-NEW-CVECTOR (THE FIXNUM 0) :ELEMENT-TYPE FIXNUM :SPARSE-ELEMENT 0)")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "MAKE-EMPTY-DIMENSIONS" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST ((:NAME "REP-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Given arepresentation list, this function returns two values:
the Lisp code for creating empty dimensions for those representations,
and a hashtable that maps symbols like EMPTY-REP- to those empty
structures. For example,

 (make-empty-dimensions '(cvector hash array)
    ==>
   (LET ((#:EMPTY-ARRAY-847
       (MAKE-ARRAY-STRUCTURE :VALUES
                             (MAKE-ARRAY 0 :ELEMENT-TYPE 'FIXNUM
                                         :INITIAL-ELEMENT (THE FIXNUM 0))
                             :ACTIVE
                             (MAKE-ARRAY 0 :ELEMENT-TYPE '(MOD 2)
                                         :INITIAL-ELEMENT 0)
                             :MAX-CAPACITY 0))
      (#:EMPTY-HASH-846 (MAKE-HASH-TABLE :SIZE 0)))),
      #<HASHTABLE :TEST EQL :COUNT 2 {129910020})

The second value returned (the hashtable) maps:
hash    --> #:EMPTY-HASH-846
array   --> #:EMPTY-ARRAY-847

The cvector scheme was not included because it is the first in the
representation list.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CHECK-DEFSPARTN-PARAMETERS" :PACKAGE-NAME "SPARTNS" :EXTERNALP
      NIL)
     :LAMBDA-LIST
     ((:NAME "NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "REPRESENTATION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NON-ZERO" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "RESIZE-AMOUNT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION
     "This function checks the types of some parameters to defspartn.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "DEFSPARTN" :PACKAGE-NAME "SPARTNS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "NAME" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "REPRESENTATION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "NON-ZERO" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ELEMENT-TYPE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SPARSE-ELEMENT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      ((:NAME "TEST-EQUAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "EQL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
      ((:NAME "RESIZE-FUNCTION" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       ((:NAME "QUOTE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        ((:NAME "LAMBDA" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
         ((:NAME "X" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
         ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
          ((:NAME "IGNORE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
           (:NAME "X" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)))
         200)))
      ((:NAME "RESIZE-AMOUNT" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) -1)
      ((:NAME "DEF" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "T" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
      ((:NAME "DECLARE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION "Defines a new spartn scheme.
If the DEF parameter is not NIL, then functions and macros will be created to access the spartn
scheme.

If the name of the new scheme is X, then the following functions will be defined:
- (MAKE-X)
- (GET-X tensor index)
- (SET-X tensor index value)
- (DELETE-X tensor index)
- (PACK-X tensor)
- (COPY-X tensor)
The macro (TRAVERSE-X index-list value tensor body) will also be defined.

NON-ZERO is just a hint so that containers in each dimension will be created with approximately
this size. It is not a hard limit, and there is no guarantee that this will actually be the size
of the containers.

RESIZE-FUNCTION is a function that tells the amount by which container sizes is increased.
The default value is (lambda (x) 200). This may or may not be used, depending on the representation scheme.

The default value of DEF is T. You can set it to NIL if you want to use w/spartns (which will create
the same macros and functions locally anyway).

The parameter DECLARE is used to include declarations inside the defined functions. By default it is
 (optimize (speed 3) (safety 1)).")
    (:TYPE :MACRO :SYMBOL
     (:NAME "W/SPARTNS" :PACKAGE-NAME "SPARTNS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "SPARTN-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&BODY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Creates local definitions for functions and macros to access a spartn scheme.
These are the same functions and macros that DEFSPARTN creates if you pass it DEF=T.

This is useful if you don't want the overhead of function calls (including boxing and unboxing
of numbers). This macro will use LABELS and MACROLET to create the functions and macros
that access the spartns in spartn-list.

Example:
  (defspartn xyz
      ...
      :def          nil)

  (w/spartns (xyz)
    (let ((s (make-xyz)))
      (set-xyz s '(0 0 0) 0.5)
      ...))

The w/spartns S-expression will be expanded into:
  (labels ((make-xyz (...))
           (get-xyz  (...))
           (set-xyz  (...))
           ...)
    (macrolet ((traverse-xyz ...))
       (let ((s (make-xyz)))
         (set-xyz s '(0 0 0) 0.5)
         ...)))")
    (:TYPE :MACRO :SYMBOL
     (:NAME "SPARTN-CONVERT" :PACKAGE-NAME "SPARTNS" :EXTERNALP T) :LAMBDA-LIST
     ((:NAME "OLD-DATA" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&KEY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "FROM" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TO" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      ((:NAME "DESTRUCTIVE" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
       (:NAME "NIL" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)))
     :DOCUMENTATION
     "Returns a new spartn using a different representation but with the same contents as the one
given. from and to must be the names of the representation schemes (symbols, not strings).

Example:

 (defspartn hashhash
    :representation '(hash hash)
    ...)

 (defspartn
    :representation '(hash cvector)
    ...)

 (let ((mat (make-hashash)))
  (let ((mat2 (spartn-convert mat :from hashash :to hashcvec)))
    (get-hashvec mat2 '(2 3))))

Here MAT uses spartn scheme HASHHASH, which represents the tensor as a hashtable of hashtables.
MAT2 is obtained by converting MAT to scheme HASHCVEC, which represents the tensor as a hashtable
of compressed vectors.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "SPLIT-INDICES-VALUES-DONT-BIND" :PACKAGE-NAME "SPARTNS" :EXTERNALP
      NIL)
     :LAMBDA-LIST ((:NAME "TRAV" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Returns index-list values dont-bind")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "SPLIT-TRAVERSAL-DESCRIPTIONS" :PACKAGE-NAME "SPARTNS" :EXTERNALP
      NIL)
     :LAMBDA-LIST
     ((:NAME "TRAVERSAL-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Splits the descriptions of several traversals into several lists: one for
spartn type, one for the data containers, one for the variable to bind for value and
one for the lists of variables to bind for indices.

For example,
 (split-traversal-descriptions '((A data-a i j k l val-a)
                                 (B data-b x y z   val-b :dont-bind (x))
                                 (C data-c a b c   val-c)))
 ==>

 (values (A B C)
	 (DATA-A DATA-B DATA-C)
	 (VAL-A VAL-B VAL-C)
	 ((I J K L) (X Y Z) (A B C))
         (NIL (x) NIL))

This is used by the macro w/spartns.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "WITH-SPARTN-TRAVERSALS-AUX" :PACKAGE-NAME "SPARTNS" :EXTERNALP
      NIL)
     :LAMBDA-LIST
     ((:NAME "SPARTN-TYPE-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DATA-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX-LIST-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "VALUE-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "DONT-BINDS" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "USED-INDEX-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Generates the code to traverse several spartns, possibly with shared indices.
This function does the heavy work, while w/spartn-traversals is the macro that exposes the
functionality.

 (with-spartn-traversals-aux '(number2d fixnum2d) '(A B) '((I J) (x y)) '(va vb) '(pprint))

==>

 (TRAVERSE-NUMBER2D ((I J) VA A)
   (TRAVERSE-FIXNUM2D ((X Y) VB B)
     (PROGN PPRINT))

Now an example with an excluded index:

 (with-spartn-traversals-aux '(number-2d fixnum-2d)
                             '(A B)
                             '((I J) (x y))
                             '(va vb)
                             '(x)  ;; <======= HERE!
                             '(progn
                                (pprint x)
                                (pprint y)
                                (pprint va)))

==>

 (TRAVERSE-NUMBER-2D ((I J) VA A)
  (TRAVERSE-FIXNUM-2D ((#:B-X-803 Y) VB B)
   (WHEN (AND (EQL X #:B-X-803))
     (PROGN PROGN (PPRINT X) (PPRINT Y) (PPRINT VA)))))

Note that the X index was excluded from the variables over which
we loop. The code will loop over #:B-X-803 (locally created), but
the body will only be evaluated if it is equal to X, which should
be set outside the loop. This is equivalent to using a fixed value
for one index.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "W/SPARTN-TRAVERSALS" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "TRAVERSAL-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&BODY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Traverses several tensors, possibly synchronizing indices. For example:

 (w/spartn-traversals ((A data-a i j k l val-a)
                       (B data-b i j k   val-b)
   ...)

Will traverse data-a and data-b (of type A and B respectively), looping over l.

 (w/spartn-traversals ((A data-a i j k l val-a)
                       (B data-b a b i j val-b)
                       (C data-c i a m n val-c :dont-bind (b m)))
   ...)

Will traverse data-a, data-b and data-c, but the only entries will be those
such that the first index on data-a and data-c are equal to that of the second
index of data-b, and so on.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "COLLECT-NON-ZEROS-INTO-FAST-TRAVERSAL" :PACKAGE-NAME "SPARTNS"
      :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "SYMBOL-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ARRAY-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPES-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "POSITION" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T))
     :DOCUMENTATION "Produces the code to SETF values in a fast traversal:

 (collect-non-zeros-into-fast-traversal '(i j k v w)
                                        '(II JJ KK VV WW)
                                        '(fixnum fixnum fixnum double-float double-float)
                                        10)
  ==>
 ((SETF (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) II) 10) I)
  (SETF (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) JJ) 10) J)
  (SETF (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) KK) 10) K)
  (SETF (AREF (THE (SIMPLE-ARRAY DOUBLE-FLOAT (*)) VV) 10) V)
  (SETF (AREF (THE (SIMPLE-ARRAY DOUBLE-FLOAT (*)) WW) 10) W))")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "FLATTEN" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL) :LAMBDA-LIST
     ((:NAME "LIST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)) :DOCUMENTATION
     "Flattens a list.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "MAKE-TYPES-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "TYPE-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "INDEX-SYMBOL-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Make s alist of types:

 (make-types-list '(hash-float cvector-double) '(i j k l))

==>
 '(single-float double-float fixnum fixnum fixnum fixnum)

type-list is a list of spartn schemes.")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "CREATE-AND-BIND-ARRAYS" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "NON-ZEROS" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "SYMBOL-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPE-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Generates the code to create and bind arrays, and also the
type declarations. For example:

 (multiple-value-bind (n b d)
     (create-and-bind-arrays 4 '(x y z w) '(fixnum character double-float fixnum))
   (format t \"=======n:~%~a~%=======b:~%~a~%=======d:~%~a~%\" n b d))

The output is:

 (ARRAY-X-2960 ARRAY-Y-2961 ARRAY-Z-2962 ARRAY-W-2963)
 =======b:
 ((ARRAY-X-2960 (MAKE-ARRAY 4 ELEMENT-TYPE FIXNUM))
  (ARRAY-Y-2961 (MAKE-ARRAY 4 ELEMENT-TYPE CHARACTER))
  (ARRAY-Z-2962 (MAKE-ARRAY 4 ELEMENT-TYPE DOUBLE-FLOAT))
  (ARRAY-W-2963 (MAKE-ARRAY 4 ELEMENT-TYPE FIXNUM)))
 =======d:
 ((TYPE (SIMPLE-ARRAY FIXNUM (*)) ARRAY-X-2960)
  (TYPE (SIMPLE-ARRAY CHARACTER (*)) ARRAY-Y-2961)
  (TYPE (SIMPLE-ARRAY DOUBLE-FLOAT (*)) ARRAY-Z-2962)
  (TYPE (SIMPLE-ARRAY FIXNUM (*)) ARRAY-W-2963))")
    (:TYPE :FUNCTION :SYMBOL
     (:NAME "DO-FAST-TRAVERSAL" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
     :LAMBDA-LIST
     ((:NAME "SYMBOL-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "ARRAY-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "TYPES-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION "Traverses a structure of the type spartn-fast-traversal,
binding the symbols for indices and values.

Example:
   (do-fast-traversal '(i j k)     ; indices
                      '(v1 v2 v3)  ; arrays
                      '(fixnum double-float double-float) ; types
     '((format t \"i=~a  j=~a  k=~a~%\" i j k))))           ; body

 ==>

 (SYMBOL-MACROLET ((I (AREF (THE (SIMPLE-ARRAY FIXNUM       (*)) V1) #:INDEX-2309))
                   (J (AREF (THE (SIMPLE-ARRAY DOUBLE-FLOAT (*)) V2) #:INDEX-2309))
                   (K (AREF (THE (SIMPLE-ARRAY DOUBLE-FLOAT (*)) V3) #:INDEX-2309)))
   (LOOP FOR #:INDEX-2309 BELOW 4 DO
     (FORMAT T \"i=~a  j=~a  k=~a~%\" I J K)))

The symbol used for the index variable (#:INDEX-2309 in this example) is created
by gensym.

*NOTE* that we used '(( body )) when calling do-fast-traversal, and ,@body inside it.")
    (:TYPE :MACRO :SYMBOL
     (:NAME "W/FAST-TRAVERSALS" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "TRAVERSAL-LIST" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL)
      (:NAME "&BODY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "BODY" :PACKAGE-NAME "SPARTNS" :EXTERNALP NIL))
     :DOCUMENTATION
     "Builds a structure of the type SPARTN-FAST-TRAVERSAL and calls do-fast-traversal
to actually run through it.

 (spartns:w/fast-traversals ((2d-matrix m1 i j val-1)
                             (2d-matrix m2 x y val-2))
   (set-2d-matrix prod
                  (+ (* i 5) x)
                  (+ (* j 5) y)
                  (* val-1 val-2)))
==>

 (LET ((#:POSITION-830 0)
      (#:ARRAY-VAL-1-831 (MAKE-ARRAY 1000 :ELEMENT-TYPE 'NUMBER))
      (#:ARRAY-VAL-2-832 (MAKE-ARRAY 1000 :ELEMENT-TYPE 'NUMBER))
      (#:ARRAY-I-833 (MAKE-ARRAY 1000 :ELEMENT-TYPE 'FIXNUM))
      (#:ARRAY-J-834 (MAKE-ARRAY 1000 :ELEMENT-TYPE 'FIXNUM))
      (#:ARRAY-X-835 (MAKE-ARRAY 1000 :ELEMENT-TYPE 'FIXNUM))
      (#:ARRAY-Y-836 (MAKE-ARRAY 1000 :ELEMENT-TYPE 'FIXNUM)))
  (DECLARE (TYPE FIXNUM #:POSITION-830)
	   (TYPE (SIMPLE-ARRAY NUMBER (*)) #:ARRAY-VAL-1-831)
	   (TYPE (SIMPLE-ARRAY NUMBER (*)) #:ARRAY-VAL-2-832)
	   (TYPE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-I-833)
	   (TYPE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-J-834)
	   (TYPE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-X-835)
	   (TYPE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-Y-836))
  ;; w/spartn-traversals will go make the traversal we'd like to do
  ;; repeatedly; we'll store the indices AND values:
  (SPARTNS:W/SPARTN-TRAVERSALS
      ((2D-MATRIX M1 I J VAL-1) (2D-MATRIX M2 X Y VAL-2))
    (SETF (AREF (THE (SIMPLE-ARRAY NUMBER (*)) #:ARRAY-VAL-1-831) #:POSITION-830) VAL-1)
    (SETF (AREF (THE (SIMPLE-ARRAY NUMBER (*)) #:ARRAY-VAL-2-832) #:POSITION-830) VAL-2)
    (SETF (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-I-833) #:POSITION-830) I)
    (SETF (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-J-834) #:POSITION-830) J)
    (SETF (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-X-835) #:POSITION-830) X)
    (SETF (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-Y-836) #:POSITION-830) Y)
    (INCF #:POSITION-830)
    ;; (car array-names): all ararys have the same size. If the first one is
    ;; full, increase the size of all of them:
    (WHEN (>= #:POSITION-830 (THE FIXNUM (LENGTH #:ARRAY-VAL-1-831)))
      (SETF #:ARRAY-VAL-1-831
	    (JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-VAL-1-831
					  (THE FIXNUM (+ 1000 #:POSITION-830))
					  :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-VAL-1-831)))
      (SETF #:ARRAY-VAL-2-832
	    (JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-VAL-2-832
					  (THE FIXNUM (+ 1000 #:POSITION-830))
					  :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-VAL-2-832)))
      (SETF #:ARRAY-I-833
	    (JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-I-833
					  (THE FIXNUM (+ 1000 #:POSITION-830))
					  :ELEMENT-TYPE
					  (ARRAY-ELEMENT-TYPE #:ARRAY-I-833)))
      (SETF #:ARRAY-J-834
	    (JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-J-834
					  (THE FIXNUM (+ 1000 #:POSITION-830))
					  :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-J-834)))
      (SETF #:ARRAY-X-835
	    (JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-X-835
					  (THE FIXNUM (+ 1000 #:POSITION-830))
					  :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-X-835)))
      (SETF #:ARRAY-Y-836
	    (JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-Y-836
					  (THE FIXNUM (+ 1000 #:POSITION-830))
					  :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-Y-836)))))
  ;; position now holds the size of the final traversal, so we adjust all arrays to that
  ;; size:
  (SETQ #:ARRAY-VAL-1-831
	(JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-VAL-1-831 #:POSITION-830
				      :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-VAL-1-831)))
  (SETQ #:ARRAY-VAL-2-832
	(JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-VAL-2-832 #:POSITION-830
				      :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-VAL-2-832)))
  (SETQ #:ARRAY-I-833
	(JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-I-833 #:POSITION-830
				      :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-I-833)))
  (SETQ #:ARRAY-J-834
	(JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-J-834 #:POSITION-830
				      :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-J-834)))
  (SETQ #:ARRAY-X-835
	(JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-X-835 #:POSITION-830
				      :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-X-835)))
  (SETQ #:ARRAY-Y-836
	(JP-UTILS:ROBUST-ADJUST-ARRAY #:ARRAY-Y-836 #:POSITION-830
				      :ELEMENT-TYPE (ARRAY-ELEMENT-TYPE #:ARRAY-Y-836)))
  (SYMBOL-MACROLET ((VAL-1 (AREF (THE (SIMPLE-ARRAY NUMBER (*)) #:ARRAY-VAL-1-831) #:INDEX-837))
                    (VAL-2 (AREF (THE (SIMPLE-ARRAY NUMBER (*)) #:ARRAY-VAL-2-832) #:INDEX-837))
                    (I (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-I-833)     #:INDEX-837))
                    (J (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-J-834)     #:INDEX-837))
                    (X (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-X-835)     #:INDEX-837))
                    (Y (AREF (THE (SIMPLE-ARRAY FIXNUM (*)) #:ARRAY-Y-836)     #:INDEX-837)))
    (LOOP FOR #:INDEX-837 BELOW (LENGTH #:ARRAY-VAL-1-831) DO
	 (SET-2D-MATRIX PROD (+ (* I 5) X) (+ (* J 5) Y) (* VAL-1 VAL-2)))))

*NOTE*: When you do a fast-traversal, you are NOT operating on the original structures
anymore, but on a copy (see the code above).
"))
   :EXTERNAL-SYMBOLS
   ((:NAME "W/SPARTNS" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
    (:NAME "CVECTOR" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
    (:NAME "HASH" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
    (:NAME "SPARTN-CONVERT" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
    (:NAME "DEFSPARTN" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
    (:NAME "W/SPARTN-TRAVERSALS" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
    (:NAME "W/FAST-TRAVERSALS" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)
    (:NAME "ARRAY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
    (:NAME "DEFSCHEME" :PACKAGE-NAME "SPARTNS" :EXTERNALP T)))))
