
(:TYPE :SYSTEM :NAME "clack-app-route" :AUTHOR "Eitarow Fukamachi" :MAINTAINER
 NIL :VERSION "12.3" :LICENCE "LLGPL" :DESCRIPTION "URL dispatcher"
 :LONG-DESCRIPTION NIL :DEPENDS-ON
 ("CLACK" "CL-SYNTAX" "CL-SYNTAX-ANNOT" "CL-PPCRE" "ALEXANDRIA") :PACKAGE-LIST
 ((:TYPE :PACKAGE :NAME "CLACK.APP.ROUTE" :FULL-NAME "CLACK.APP.ROUTE"
   :DOCUMENTATION "# 
Clack.App.Route - URL dispatcher.


## SYNOPSIS

    (defpackage clack-sample
      (:use :cl
            :clack
            :clack.app.route))
    (in-package :clack-sample)
    
    (defroutes app
      (GET \"/\" #'index)
      (GET \"/login\" #'login)
      (POST \"/login\" #'authorize)
      (GET \"/member/:id\" #'member))
    
    (clackup #'app)

## DESCRIPTION

Clack.App.Route provides an URL based dispacher, inspired by Ruby's Sinatra. Each routing rules contains three elements, REQUEST-METHOD, URI rule and Clack Application.

Clack Application is a function or Clack.Component which takes exact one argument. It is a property list represents Environment.

    (defroutes app
      (GET \"/\"
           (lambda (env)
             '(200
               (:content-type \"text/plain\")
               (\"Hello. This is an index page.\")))))

Routing URI rules are also allowed to contain named parameters or wild cards. Then, Clack.App.Route adds `:route.parameters` to `env`.

    (defroutes app
      (GET \"/member/:id\"
           (lambda (env)
             (destructuring-bind (&key id &allow-other-keys)
                 (getf env :route.parameters)
               `(200
                 (:content-type \"text/plain\")
                 (,(format nil \"Your member ID is ~D\" id))))))
      (GET \"/say/*/to/*\"
           (lambda (env)
             (destructuring-bind (who what)
                 (getf (getf env :route.parameters) :splat)
               `(200
                 (:content-type \"text/plain\")
                 (,(format nil \"You're saying ~A to ~A\" what who)))))))

This package is using Clack.Util.Route to parse rule strings.

Note: Though `parse-url-rule` is provided from this package now, it is now deprecated. Use Clack.Util.Route for instead.

## AUTHOR

* Tomohiro Matsuyama (tomo@cx4a.org)

## CONTRIBUTORS

* Eitarow Fukamachi (e.arrows@gmail.com)

## SEE ALSO

* Clack.Util.Route

"
   :SYMBOL-LIST
   ((:TYPE :FUNCTION :SYMBOL
     (:NAME "PARSE-URL-RULE" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "URL" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP NIL))
     :DOCUMENTATION "
[DEPRECATED]
Parse an URL rule and return a list of (regex control-string
variables).

Example:
  (parse-url-rule \"/login\")
  ;;=> (\"^\\/login$\" \"/login\" NIL)
  (parse-url-rule \"/member/:id\")
  ;;=> (\"^\\/member\\/(.+?)$\" \"/member/~A\" (ID))
")
    (:TYPE :MACRO :SYMBOL
     (:NAME "DEFROUTES" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP T)
     :LAMBDA-LIST
     ((:NAME "NAME" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP NIL)
      (:NAME "&BODY" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      (:NAME "ROUTES" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP NIL)
      (:NAME "&AUX" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
      ((:NAME "OTHERWISE" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
       ((:NAME "LAST" :PACKAGE-NAME "COMMON-LISP" :EXTERNALP T)
        (:NAME "ROUTES" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP NIL))))
     :DOCUMENTATION NIL))
   :EXTERNAL-SYMBOLS
   ((:NAME "PARSE-URL-RULE" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP T)
    (:NAME "DEFROUTES" :PACKAGE-NAME "CLACK.APP.ROUTE" :EXTERNALP T)))))
