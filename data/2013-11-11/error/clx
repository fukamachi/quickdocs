; in: QUICKDOCS.PARSER.UTIL:WITH-RETRYING 5
;     (LET ((#:RETRY-RECOMPILE983 5)
;           (#:RETRY-CONTINUE984 5)
;           (#:RETRY-LOAD-SYSTEM985 5))
;       (HANDLER-BIND ((ERROR (LAMBDA # #)) (ERROR (LAMBDA # #)))
;         (QUICKDOCS.PARSER:PARSE-DOCUMENTATION (ASDF/SYSTEM:FIND-SYSTEM "clx"))))
; 
; caught STYLE-WARNING:
;   The variable #:RETRY-LOAD-SYSTEM985 is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/clx.lisp
; in: DEFUN ENCODE-EVENT-MASK
;     (XLIB::X-TYPE-ERROR XLIB:EVENT-MASK 'XLIB:EVENT-MASK)
; ==>
;   XLIB:EVENT-MASK
; 
; note: deleting unreachable code

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/clx.lisp
; in: DEFUN ENCODE-DEVICE-EVENT-MASK
;     (XLIB::X-TYPE-ERROR XLIB:DEVICE-EVENT-MASK 'XLIB:DEVICE-EVENT-MASK)
; ==>
;   XLIB:DEVICE-EVENT-MASK
; 
; note: deleting unreachable code

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/clx.lisp
; in: DEFUN ENCODE-MODIFIER-MASK
;     (XLIB::X-TYPE-ERROR XLIB:MODIFIER-MASK 'XLIB:MODIFIER-MASK)
; ==>
;   XLIB:MODIFIER-MASK
; 
; note: deleting unreachable code

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/clx.lisp
; in: DEFUN ENCODE-STATE-MASK
;     (XLIB::X-TYPE-ERROR XLIB::STATE-MASK
;                         '(OR XLIB:MASK16 (XLIB::CLX-LIST XLIB:STATE-MASK-KEY)))
; ==>
;   XLIB::STATE-MASK
; 
; note: deleting unreachable code

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/clx.lisp
; in: DEFUN ENCODE-POINTER-EVENT-MASK
;     (XLIB::X-TYPE-ERROR XLIB:POINTER-EVENT-MASK 'XLIB:POINTER-EVENT-MASK)
; ==>
;   XLIB:POINTER-EVENT-MASK
; 
; note: deleting unreachable code
; 
; compilation unit finished
;   printed 5 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN INT32->CARD32
;     (DEFUN XLIB::INT32->CARD32 (XLIB::X)
;       (DECLARE (TYPE XLIB:INT32 XLIB::X))
;       (DECLARE (XLIB::CLX-VALUES XLIB:CARD32))
;       (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;       (THE XLIB:CARD32 (LDB (BYTE 32 0) XLIB::X)))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'XLIB::INT32->CARD32
;                    (SB-INT:NAMED-LAMBDA XLIB::INT32->CARD32
;                        (XLIB::X)
;                      (DECLARE (TYPE XLIB:INT32 XLIB::X))
;                      (DECLARE (XLIB::CLX-VALUES XLIB:CARD32))
;                      (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;                      (BLOCK XLIB::INT32->CARD32
;                        (THE XLIB:CARD32 (LDB # XLIB::X))))
;                    NIL
;                    '(SB-C:LAMBDA-WITH-LEXENV NIL NIL NIL (XLIB::X)
;                      (DECLARE (TYPE XLIB:INT32 XLIB::X))
;                      (DECLARE (XLIB::CLX-VALUES XLIB:CARD32))
;                      (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;                      (BLOCK XLIB::INT32->CARD32
;                        (THE XLIB:CARD32 (LDB # XLIB::X))))
;                    (SB-C:SOURCE-LOCATION))
; 
; note: doing unsigned word to integer coercion (cost 20) to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN AREF-CARD32
;     (DEFUN XLIB::AREF-CARD32 (XLIB::A XLIB::I)
;       (DECLARE (TYPE XLIB::BUFFER-BYTES XLIB::A)
;                (TYPE XLIB:ARRAY-INDEX XLIB::I))
;       (DECLARE (XLIB::CLX-VALUES XLIB:CARD32))
;       (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;       (THE XLIB:CARD32
;            (LOGIOR (THE XLIB:CARD32 (ASH # 24)) (THE XLIB:CARD29 (ASH # 16))
;                    (THE XLIB:CARD16 (ASH # 8))
;                    (THE XLIB:CARD8 (AREF XLIB::A #)))))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'XLIB::AREF-CARD32
;                    (SB-INT:NAMED-LAMBDA XLIB::AREF-CARD32
;                        (XLIB::A XLIB::I)
;                      (DECLARE (TYPE XLIB::BUFFER-BYTES XLIB::A)
;                               (TYPE XLIB:ARRAY-INDEX XLIB::I))
;                      (DECLARE (XLIB::CLX-VALUES XLIB:CARD32))
;                      (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;                      (BLOCK XLIB::AREF-CARD32
;                        (THE XLIB:CARD32 (LOGIOR # # # #))))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing unsigned word to integer coercion (cost 20) to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN AREF-INT32
;     (DEFUN XLIB::AREF-INT32 (XLIB::A XLIB::I)
;       (DECLARE (TYPE XLIB::BUFFER-BYTES XLIB::A)
;                (TYPE XLIB:ARRAY-INDEX XLIB::I))
;       (DECLARE (XLIB::CLX-VALUES XLIB:INT32))
;       (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;       (THE XLIB:INT32
;            (LOGIOR (THE XLIB:INT32 (ASH # 24)) (THE XLIB:CARD29 (ASH # 16))
;                    (THE XLIB:CARD16 (ASH # 8))
;                    (THE XLIB:CARD8 (AREF XLIB::A #)))))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'XLIB::AREF-INT32
;                    (SB-INT:NAMED-LAMBDA XLIB::AREF-INT32
;                        (XLIB::A XLIB::I)
;                      (DECLARE (TYPE XLIB::BUFFER-BYTES XLIB::A)
;                               (TYPE XLIB:ARRAY-INDEX XLIB::I))
;                      (DECLARE (XLIB::CLX-VALUES XLIB:INT32))
;                      (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;                      (BLOCK XLIB::AREF-INT32
;                        (THE XLIB:INT32 (LOGIOR # # # #))))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing signed word to integer coercion (cost 20) to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN CARD16->RGB-VAL
;     (DEFUN XLIB::CARD16->RGB-VAL (XLIB::VALUE)
;       (DECLARE (TYPE XLIB:CARD16 XLIB::VALUE))
;       (DECLARE (XLIB::CLX-VALUES SHORT-FLOAT))
;       (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;       (THE SHORT-FLOAT (* (THE XLIB:CARD16 XLIB::VALUE) 1.5259022e-5)))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'XLIB::CARD16->RGB-VAL
;                    (SB-INT:NAMED-LAMBDA XLIB::CARD16->RGB-VAL
;                        (XLIB::VALUE)
;                      (DECLARE (TYPE XLIB:CARD16 XLIB::VALUE))
;                      (DECLARE (XLIB::CLX-VALUES SHORT-FLOAT))
;                      (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;                      (BLOCK XLIB::CARD16->RGB-VAL
;                        (THE SHORT-FLOAT (* # 1.5259022e-5))))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing float to pointer coercion (cost 13) to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN INT16->RADIANS
;     (DEFUN XLIB::INT16->RADIANS (XLIB::VALUE)
;       (DECLARE (TYPE XLIB:INT16 XLIB::VALUE))
;       (DECLARE (XLIB::CLX-VALUES SHORT-FLOAT))
;       (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;       (THE SHORT-FLOAT (* (THE XLIB:INT16 XLIB::VALUE) 2.727077e-4)))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'XLIB::INT16->RADIANS
;                    (SB-INT:NAMED-LAMBDA XLIB::INT16->RADIANS
;                        (XLIB::VALUE)
;                      (DECLARE (TYPE XLIB:INT16 XLIB::VALUE))
;                      (DECLARE (XLIB::CLX-VALUES SHORT-FLOAT))
;                      (DECLARE (OPTIMIZE (SPEED 3) (SAFETY 0) (DEBUG 1)))
;                      (BLOCK XLIB::INT16->RADIANS
;                        (THE SHORT-FLOAT (* # 2.727077e-4))))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing float to pointer coercion (cost 13) to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN BUFFER-READ-DEFAULT
;     (SB-SYS:READ-N-BYTES (XLIB::DISPLAY-INPUT-STREAM XLIB:DISPLAY) VECTOR
;                          XLIB::START (- XLIB::END XLIB::START))
; --> BLOCK IF LET* SB-IMPL::EOF-OR-LOSE IF AND IF AND THE 
; ==>
;   (< SB-IMPL::READ-END SB-IMPL::END)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       The second argument is a (INTEGER -536870909 1073741818), not a FIXNUM.

; --> BLOCK IF LET* 
; ==>
;   (+ SB-IMPL::START SB-IMPL::NUMBYTES)
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the first result of inline (signed-byte 32) arithmetic

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN FAST-READ-PIXARRAY
;     (XLIB::READ-PIXARRAY-INTERNAL XLIB::BBUF XLIB::BOFFSET XLIB:PIXARRAY XLIB::X
;                                   XLIB::Y XLIB::WIDTH XLIB::HEIGHT
;                                   XLIB::PADDED-BYTES-PER-LINE
;                                   XLIB::BITS-PER-PIXEL FUNCTION XLIB::UNIT ...)
; ==>
;   XLIB::BBUF
; 
; note: deleting unreachable code

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN FAST-WRITE-PIXARRAY-USING-BITBLT
;     (ARRAY-DIMENSION XLIB:PIXARRAY 1)
; 
; note: unable to
;   optimize
; because:
;   The array dimensions are unknown; must call ARRAY-DIMENSION at runtime.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/dependent.lisp
; in: DEFUN FAST-WRITE-PIXARRAY
;     (XLIB::WRITE-PIXARRAY-INTERNAL XLIB::BBUF XLIB::BOFFSET XLIB:PIXARRAY XLIB::X
;                                    XLIB::Y XLIB::WIDTH XLIB::HEIGHT
;                                    XLIB::PADDED-BYTES-PER-LINE
;                                    XLIB::BITS-PER-PIXEL FUNCTION
;                                    XLIB::+IMAGE-UNIT+ ...)
; ==>
;   XLIB::BBUF
; 
; note: deleting unreachable code
; 
; compilation unit finished
;   printed 11 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/macros.lisp
; in: DEFUN MASK-GET
;     (DEFUN XLIB::MASK-GET (XLIB::INDEX XLIB::TYPE-VALUES XLIB::BODY-FUNCTION)
;       (DECLARE (TYPE FUNCTION XLIB::BODY-FUNCTION)
;                (DYNAMIC-EXTENT XLIB::BODY-FUNCTION))
;       (LET* ((BIT 0) (XLIB::RESULT (MAPCAR #'# #)))
;         `(,@(WHEN (ATOM #) (LIST #))
;           (PROGN (SETQ #) (SETQ #) ,(CAR XLIB::RESULT)) ,@(CDR XLIB::RESULT))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1658
; 
; note: could not stack allocate BODY-FUNCTION in:
;        (DEFUN MASK-GET (INDEX TYPE-VALUES BODY-FUNCTION)
;          (DECLARE (TYPE FUNCTION BODY-FUNCTION)
;                   (DYNAMIC-EXTENT BODY-FUNCTION))
;          (LET* ((BIT 0)
;                 (RESULT
;                  (MAPCAR
;                   #'(LAMBDA (FORM)
;                       (IF (ATOM FORM)
;                           FORM
;                           (PROG1 `(WHEN (LOGBITP ,BIT %MASK) ,FORM)
;                             (INCF BIT))))
;                   (GET-PUT-ITEMS (+ INDEX 4) TYPE-VALUES NIL
;                                  #'(LAMBDA (TYPE INDEX ITEM ARGS)
;                                      (DECLARE (IGNORE INDEX))
;                                      (FUNCALL BODY-FUNCTION TYPE
;                                               '(* (INCF %INDEX) 4) ITEM
;                                               ARGS))))))
;            `(,@(WHEN (ATOM (CAR RESULT)) (LIST (POP RESULT)))
;              (PROGN
;               (SETQ %MASK (READ-CARD32 ,INDEX))
;               (SETQ %INDEX ,(CEILING INDEX 4))
;               ,(CAR RESULT))
;              ,@(CDR RESULT))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/macros.lisp
; in: DEFUN MASK-PUT
;     (DEFUN XLIB::MASK-PUT (XLIB::INDEX XLIB::TYPE-VALUES XLIB::BODY-FUNCTION)
;       (DECLARE (TYPE FUNCTION XLIB::BODY-FUNCTION)
;                (DYNAMIC-EXTENT XLIB::BODY-FUNCTION))
;       `((LET ((XLIB::%MASK 0) (XLIB::%INDEX ,XLIB::INDEX))
;           ,@(LET (#)
;               (XLIB::GET-PUT-ITEMS XLIB::INDEX XLIB::TYPE-VALUES T #'#))
;           (XLIB::WRITE-CARD32 ,XLIB::INDEX XLIB::%MASK)
;           (XLIB::WRITE-CARD16 2 (XLIB::INDEX-CEILING # 4))
;           (INCF (XLIB::BUFFER-BOFFSET XLIB::%BUFFER) XLIB::%INDEX))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1701
; 
; note: could not stack allocate BODY-FUNCTION in:
;        (DEFUN MASK-PUT (INDEX TYPE-VALUES BODY-FUNCTION)
;          (DECLARE (TYPE FUNCTION BODY-FUNCTION)
;                   (DYNAMIC-EXTENT BODY-FUNCTION))
;          `((LET ((%MASK 0) (%INDEX ,INDEX))
;              ,@(LET ((BIT 1))
;                  (GET-PUT-ITEMS INDEX TYPE-VALUES T
;                                 #'(LAMBDA (TYPE INDEX ITEM ARGS)
;                                     (DECLARE (IGNORE INDEX))
;                                     (IF (OR (SYMBOLP ITEM) (CONSTANTP ITEM))
;                                         `((UNLESS (NULL ,ITEM)
;                                             (SETQ %MASK
;                                                     (LOGIOR %MASK
;                                                             ,(SHIFTF BIT
;                                                                      (ASH BIT
;                                                                           1))))
;                                             ,@(FUNCALL BODY-FUNCTION TYPE
;                                                        '(INDEX-INCF %INDEX 4)
;                                                        ITEM ARGS)))
;                                         `((LET ((.ITEM. ,ITEM))
;                                             (UNLESS (NULL .ITEM.)
;                                               (SETQ %MASK
;                                                       (LOGIOR %MASK
;                                                               ,(SHIFTF BIT
;                                                                        (ASH BIT
;                                                                             1))))
;                                               ,@(FUNCALL BODY-FUNCTION TYPE
;                                                          '(INDEX-INCF %INDEX 4)
;                                                          '.ITEM. ARGS))))))))
;              (WRITE-CARD32 ,INDEX %MASK)
;              (WRITE-CARD16 2 (INDEX-CEILING (INDEX-INCF %INDEX 4) 4))
;              (INCF (BUFFER-BOFFSET %BUFFER) %INDEX))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/macros.lisp
; in: DEFUN GET-PUT-ITEMS
;     (DEFUN XLIB::GET-PUT-ITEMS
;            (XLIB::INDEX XLIB::TYPE-ARGS XLIB::PUTP &OPTIONAL XLIB::BODY-FUNCTION)
;       (DECLARE (TYPE (OR NULL FUNCTION) XLIB::BODY-FUNCTION)
;                (DYNAMIC-EXTENT XLIB::BODY-FUNCTION))
;       (UNLESS XLIB::BODY-FUNCTION (SETQ XLIB::BODY-FUNCTION #'(LAMBDA # `#)))
;       (DO* ((XLIB::ITEMS XLIB::TYPE-ARGS (CDR XLIB::ITEMS))
;             (TYPE (CAAR XLIB::ITEMS) (CAAR XLIB::ITEMS))
;             (XLIB::ARGS NIL NIL)
;             (XLIB::RESULT NIL)
;             (XLIB::SIZES NIL))
;            ((ENDP XLIB::ITEMS) (VALUES XLIB::RESULT XLIB::INDEX XLIB::SIZES))
;         (WHEN (CONSP TYPE)
;           (SETQ XLIB::ARGS #
;                 TYPE #))
;         (COND ((MEMBER TYPE '#)) ((EQ TYPE 'XLIB::MASK) (SETQ #))
;               (T (DO* # # # # #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF PROGN SB-C::%FUNCALL 
; --> MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G1966
; 
; note: could not stack allocate BODY-FUNCTION in:
;        (DEFUN GET-PUT-ITEMS (INDEX TYPE-ARGS PUTP &OPTIONAL BODY-FUNCTION)
;          (DECLARE (TYPE (OR NULL FUNCTION) BODY-FUNCTION)
;                   (DYNAMIC-EXTENT BODY-FUNCTION))
;          (UNLESS BODY-FUNCTION
;            (SETQ BODY-FUNCTION
;                    #'(LAMBDA (TYPE INDEX ITEM ARGS)
;                        `((CHECK-PUT ,INDEX ,ITEM ,TYPE ,@ARGS)))))
;          (DO* ((ITEMS TYPE-ARGS (CDR ITEMS))
;                (TYPE (CAAR ITEMS) (CAAR ITEMS))
;                (ARGS NIL NIL)
;                (RESULT NIL)
;                (SIZES NIL))
;               ((ENDP ITEMS) (VALUES RESULT INDEX SIZES))
;            (WHEN (CONSP TYPE)
;              (SETQ ARGS (CDR TYPE)
;                    TYPE (CAR TYPE)))
;            (COND ((MEMBER TYPE '(RETURN BUFFER)))
;                  ((EQ TYPE 'MASK)
;                   (SETQ RESULT
;                           (APPEND RESULT
;                                   (IF PUTP
;                                       (MASK-PUT INDEX (CDAR ITEMS)
;                                                 BODY-FUNCTION)
;                                       (MASK-GET INDEX (CDAR ITEMS)
;                                                 BODY-FUNCTION)))
;                         INDEX NIL))
;                  (T
;                   (DO* ((ITEM (CDAR ITEMS) (CDR ITEM))
;                         (INCREMENT (INDEX-INCREMENT TYPE)))
;                        ((ENDP ITEM))
;                     (WHEN (CONSTANTP INDEX)
;                       (CASE INCREMENT
;                         (2 (SETQ INDEX (WROUND INDEX)))
;                         (4 (SETQ INDEX (LROUND INDEX)))))
;                     (SETQ RESULT
;                             (APPEND RESULT
;                                     (FUNCALL BODY-FUNCTION TYPE INDEX
;                                              (CAR ITEM) ARGS)))
;                     (WHEN (CONSTANTP INDEX)
;                       (IF (NULL INCREMENT)
;                           (SETQ INDEX NIL)
;                           (PROGN
;                            (INCF INDEX INCREMENT)
;                            (WHEN (AND INCREMENT (ZEROP INCREMENT))
;                              (SETQ INCREMENT 1))
;                            (PUSHNEW (* INCREMENT 8) SIZES)))))))))
; 
; compilation unit finished
;   printed 3 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WITH-BUFFER-FUNCTION
;     (XLIB::WITH-BUFFER (XLIB::BUFFER :TIMEOUT XLIB::TIMEOUT :INLINE T)
;       (FUNCALL FUNCTION))
; --> MACROLET LET XLIB::HOLDING-LOCK IF HANDLER-CASE SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 WITH-TIMEOUT SB-INT:DX-FLET FLET LET IF 
; ==>
;   (> SB-IMPL::EXPIRES 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a REAL, not a FLOAT.

;     (DEFUN XLIB::WITH-BUFFER-FUNCTION (XLIB::BUFFER XLIB::TIMEOUT FUNCTION)
;       (DECLARE (TYPE XLIB:DISPLAY XLIB::BUFFER)
;                (TYPE (OR NULL NUMBER) XLIB::TIMEOUT)
;                (TYPE FUNCTION FUNCTION)
;                (DYNAMIC-EXTENT FUNCTION)
;                (IGNORABLE XLIB::TIMEOUT))
;       (XLIB::WITH-BUFFER (XLIB::BUFFER :TIMEOUT XLIB::TIMEOUT :INLINE T)
;         (FUNCALL FUNCTION)))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G118
; 
; note: could not stack allocate FUNCTION in:
;        (DEFUN WITH-BUFFER-FUNCTION (BUFFER TIMEOUT FUNCTION)
;          (DECLARE (TYPE DISPLAY BUFFER)
;                   (TYPE (OR NULL NUMBER) TIMEOUT)
;                   (TYPE FUNCTION FUNCTION)
;                   (DYNAMIC-EXTENT FUNCTION)
;                   (IGNORABLE TIMEOUT))
;          (WITH-BUFFER (BUFFER :TIMEOUT TIMEOUT :INLINE T)
;            (FUNCALL FUNCTION)))

;     (XLIB::WITH-BUFFER (XLIB::BUFFER :TIMEOUT XLIB::TIMEOUT :INLINE T)
;       (FUNCALL FUNCTION))
; --> MACROLET LET XLIB::HOLDING-LOCK IF HANDLER-CASE SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 WITH-TIMEOUT SB-INT:DX-FLET FLET LET IF 
; ==>
;   (> SB-IMPL::EXPIRES 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a REAL, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a REAL, not a FIXNUM.
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WITH-BUFFER-REQUEST-FUNCTION
;     (DEFUN XLIB::WITH-BUFFER-REQUEST-FUNCTION
;            (XLIB:DISPLAY XLIB::GC-FORCE XLIB::REQUEST-FUNCTION)
;       (DECLARE (TYPE XLIB:DISPLAY XLIB:DISPLAY)
;                (TYPE (OR NULL XLIB:GCONTEXT) XLIB::GC-FORCE))
;       (DECLARE (TYPE FUNCTION XLIB::REQUEST-FUNCTION)
;                (DYNAMIC-EXTENT XLIB::REQUEST-FUNCTION))
;       (XLIB::WITH-BUFFER (XLIB:DISPLAY :INLINE T)
;         (MULTIPLE-VALUE-PROG1
;             (PROGN
;              (WHEN XLIB::GC-FORCE #)
;              (XLIB::WITHOUT-ABORTS
;                #))
;           (XLIB:DISPLAY-INVOKE-AFTER-FUNCTION XLIB:DISPLAY))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G438
; 
; note: could not stack allocate REQUEST-FUNCTION in:
;        (DEFUN WITH-BUFFER-REQUEST-FUNCTION (DISPLAY GC-FORCE REQUEST-FUNCTION)
;          (DECLARE (TYPE DISPLAY DISPLAY)
;                   (TYPE (OR NULL GCONTEXT) GC-FORCE))
;          (DECLARE (TYPE FUNCTION REQUEST-FUNCTION)
;                   (DYNAMIC-EXTENT REQUEST-FUNCTION))
;          (WITH-BUFFER (DISPLAY :INLINE T)
;            (MULTIPLE-VALUE-PROG1
;                (PROGN
;                 (WHEN GC-FORCE (FORCE-GCONTEXT-CHANGES-INTERNAL GC-FORCE))
;                 (WITHOUT-ABORTS
;                   (FUNCALL REQUEST-FUNCTION DISPLAY)))
;              (DISPLAY-INVOKE-AFTER-FUNCTION DISPLAY))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WITH-BUFFER-REQUEST-FUNCTION-NOLOCK
;     (DEFUN XLIB::WITH-BUFFER-REQUEST-FUNCTION-NOLOCK
;            (XLIB:DISPLAY XLIB::GC-FORCE XLIB::REQUEST-FUNCTION)
;       (DECLARE (TYPE XLIB:DISPLAY XLIB:DISPLAY)
;                (TYPE (OR NULL XLIB:GCONTEXT) XLIB::GC-FORCE))
;       (DECLARE (TYPE FUNCTION XLIB::REQUEST-FUNCTION)
;                (DYNAMIC-EXTENT XLIB::REQUEST-FUNCTION))
;       (MULTIPLE-VALUE-PROG1
;           (PROGN
;            (WHEN XLIB::GC-FORCE
;              (XLIB::FORCE-GCONTEXT-CHANGES-INTERNAL XLIB::GC-FORCE))
;            (XLIB::WITHOUT-ABORTS
;              (FUNCALL XLIB::REQUEST-FUNCTION XLIB:DISPLAY)))
;         (XLIB:DISPLAY-INVOKE-AFTER-FUNCTION XLIB:DISPLAY)))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G451
; 
; note: could not stack allocate REQUEST-FUNCTION in:
;        (DEFUN WITH-BUFFER-REQUEST-FUNCTION-NOLOCK
;               (DISPLAY GC-FORCE REQUEST-FUNCTION)
;          (DECLARE (TYPE DISPLAY DISPLAY)
;                   (TYPE (OR NULL GCONTEXT) GC-FORCE))
;          (DECLARE (TYPE FUNCTION REQUEST-FUNCTION)
;                   (DYNAMIC-EXTENT REQUEST-FUNCTION))
;          (MULTIPLE-VALUE-PROG1
;              (PROGN
;               (WHEN GC-FORCE (FORCE-GCONTEXT-CHANGES-INTERNAL GC-FORCE))
;               (WITHOUT-ABORTS
;                 (FUNCALL REQUEST-FUNCTION DISPLAY)))
;            (DISPLAY-INVOKE-AFTER-FUNCTION DISPLAY)))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WITH-BUFFER-REQUEST-AND-REPLY-FUNCTION
;     (DEFUN XLIB::WITH-BUFFER-REQUEST-AND-REPLY-FUNCTION
;            (XLIB:DISPLAY XLIB::MULTIPLE-REPLY XLIB::REQUEST-FUNCTION
;             XLIB::REPLY-FUNCTION)
;       (DECLARE (TYPE XLIB:DISPLAY XLIB:DISPLAY)
;                (TYPE XLIB:GENERALIZED-BOOLEAN XLIB::MULTIPLE-REPLY))
;       (DECLARE (TYPE FUNCTION XLIB::REQUEST-FUNCTION XLIB::REPLY-FUNCTION)
;                (DYNAMIC-EXTENT XLIB::REQUEST-FUNCTION XLIB::REPLY-FUNCTION))
;       (LET ((XLIB::PENDING-COMMAND NIL) (XLIB::REPLY-BUFFER NIL))
;         (DECLARE (TYPE (OR NULL XLIB::PENDING-COMMAND) XLIB::PENDING-COMMAND)
;                  (TYPE (OR NULL XLIB::REPLY-BUFFER) XLIB::REPLY-BUFFER))
;         (UNWIND-PROTECT
;             (PROGN
;              (XLIB::WITH-BUFFER #
;                #
;                #
;                #
;                #)
;              (COND # #))
;           (WHEN XLIB::REPLY-BUFFER
;             (XLIB::DEALLOCATE-REPLY-BUFFER XLIB::REPLY-BUFFER))
;           (WHEN XLIB::PENDING-COMMAND
;             (XLIB::STOP-PENDING-COMMAND XLIB:DISPLAY XLIB::PENDING-COMMAND)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G541
; 
; note: could not stack allocate REQUEST-FUNCTION in:
;        (DEFUN WITH-BUFFER-REQUEST-AND-REPLY-FUNCTION
;               (DISPLAY MULTIPLE-REPLY REQUEST-FUNCTION REPLY-FUNCTION)
;          (DECLARE (TYPE DISPLAY DISPLAY)
;                   (TYPE GENERALIZED-BOOLEAN MULTIPLE-REPLY))
;          (DECLARE (TYPE FUNCTION REQUEST-FUNCTION REPLY-FUNCTION)
;                   (DYNAMIC-EXTENT REQUEST-FUNCTION REPLY-FUNCTION))
;          (LET ((PENDING-COMMAND NIL) (REPLY-BUFFER NIL))
;            (DECLARE (TYPE (OR NULL PENDING-COMMAND) PENDING-COMMAND)
;                     (TYPE (OR NULL REPLY-BUFFER) REPLY-BUFFER))
;            (UNWIND-PROTECT
;                (PROGN
;                 (WITH-BUFFER (DISPLAY :INLINE T)
;                   (SETQ PENDING-COMMAND (START-PENDING-COMMAND DISPLAY))
;                   (WITHOUT-ABORTS
;                     (FUNCALL REQUEST-FUNCTION DISPLAY))
;                   (BUFFER-FORCE-OUTPUT DISPLAY)
;                   (DISPLAY-INVOKE-AFTER-FUNCTION DISPLAY))
;                 (COND
;                  (MULTIPLE-REPLY
;                   (LOOP
;                    (SETQ REPLY-BUFFER (READ-REPLY DISPLAY PENDING-COMMAND))
;                    (WHEN (FUNCALL REPLY-FUNCTION DISPLAY REPLY-BUFFER)
;                      (RETURN NIL))
;                    (DEALLOCATE-REPLY-BUFFER (SHIFTF REPLY-BUFFER NIL))))
;                  (T (SETQ REPLY-BUFFER (READ-REPLY DISPLAY PENDING-COMMAND))
;                   (FUNCALL REPLY-FUNCTION DISPLAY REPLY-BUFFER))))
;              (WHEN REPLY-BUFFER (DEALLOCATE-REPLY-BUFFER REPLY-BUFFER))
;              (WHEN PENDING-COMMAND
;                (STOP-PENDING-COMMAND DISPLAY PENDING-COMMAND)))))

; ==>
;   #:G542
; 
; note: could not stack allocate REPLY-FUNCTION in:
;        (DEFUN WITH-BUFFER-REQUEST-AND-REPLY-FUNCTION
;               (DISPLAY MULTIPLE-REPLY REQUEST-FUNCTION REPLY-FUNCTION)
;          (DECLARE (TYPE DISPLAY DISPLAY)
;                   (TYPE GENERALIZED-BOOLEAN MULTIPLE-REPLY))
;          (DECLARE (TYPE FUNCTION REQUEST-FUNCTION REPLY-FUNCTION)
;                   (DYNAMIC-EXTENT REQUEST-FUNCTION REPLY-FUNCTION))
;          (LET ((PENDING-COMMAND NIL) (REPLY-BUFFER NIL))
;            (DECLARE (TYPE (OR NULL PENDING-COMMAND) PENDING-COMMAND)
;                     (TYPE (OR NULL REPLY-BUFFER) REPLY-BUFFER))
;            (UNWIND-PROTECT
;                (PROGN
;                 (WITH-BUFFER (DISPLAY :INLINE T)
;                   (SETQ PENDING-COMMAND (START-PENDING-COMMAND DISPLAY))
;                   (WITHOUT-ABORTS
;                     (FUNCALL REQUEST-FUNCTION DISPLAY))
;                   (BUFFER-FORCE-OUTPUT DISPLAY)
;                   (DISPLAY-INVOKE-AFTER-FUNCTION DISPLAY))
;                 (COND
;                  (MULTIPLE-REPLY
;                   (LOOP
;                    (SETQ REPLY-BUFFER (READ-REPLY DISPLAY PENDING-COMMAND))
;                    (WHEN (FUNCALL REPLY-FUNCTION DISPLAY REPLY-BUFFER)
;                      (RETURN NIL))
;                    (DEALLOCATE-REPLY-BUFFER (SHIFTF REPLY-BUFFER NIL))))
;                  (T (SETQ REPLY-BUFFER (READ-REPLY DISPLAY PENDING-COMMAND))
;                   (FUNCALL REPLY-FUNCTION DISPLAY REPLY-BUFFER))))
;              (WHEN REPLY-BUFFER (DEALLOCATE-REPLY-BUFFER REPLY-BUFFER))
;              (WHEN PENDING-COMMAND
;                (STOP-PENDING-COMMAND DISPLAY PENDING-COMMAND)))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-CHAR
;     (XLIB::DEFINE-TRANSFORMED-SEQUENCE-READER XLIB::READ-SEQUENCE-CHAR CHARACTER
;                                               XLIB:CARD8->CHAR
;                                               XLIB::READ-SEQUENCE-CARD8)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> COND IF PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G871
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-CHAR CHARACTER
;                                            CARD8->CHAR READ-SEQUENCE-CARD8)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-READERS (READ-LIST-CARD8 READ-LIST-CARD8-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-READERS
;      (XLIB::READ-LIST-CARD8 XLIB::READ-LIST-CARD8-WITH-TRANSFORM) XLIB:CARD8 8 1
;      XLIB::READ-CARD8)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1055
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-READERS (READ-LIST-CARD8 READ-LIST-CARD8-WITH-TRANSFORM)
;                             CARD8 8 1 READ-CARD8)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM
;     (DEFUN XLIB::READ-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM
;            (XLIB::REPLY-BUFFER XLIB::NITEMS XLIB::DATA XLIB::TRANSFORM
;             XLIB::START XLIB::INDEX)
;       (DECLARE (TYPE XLIB::REPLY-BUFFER XLIB::REPLY-BUFFER)
;                (TYPE XLIB:ARRAY-INDEX XLIB::NITEMS XLIB::START XLIB::INDEX)
;                (TYPE (SIMPLE-ARRAY XLIB:CARD8 (*)) XLIB::DATA))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD8) XLIB:CARD8) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:CARD8 (*)))
;         (XLIB::WITH-BUFFER-INPUT (XLIB::REPLY-BUFFER :SIZES (8) :INDEX
;                                   XLIB::INDEX)
;           (DO* (#
;                 #
;                 #)
;                (#)
;             (DECLARE #)
;             (SETF #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1133
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN READ-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM
;               (REPLY-BUFFER NITEMS DATA TRANSFORM START INDEX)
;          (DECLARE (TYPE REPLY-BUFFER REPLY-BUFFER)
;                   (TYPE ARRAY-INDEX NITEMS START INDEX)
;                   (TYPE (SIMPLE-ARRAY CARD8 (*)) DATA))
;          (DECLARE (TYPE (FUNCTION (CARD8) CARD8) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY CARD8 (*)))
;            (WITH-BUFFER-INPUT (REPLY-BUFFER :SIZES (8) :INDEX INDEX)
;              (DO* ((J START (INDEX+ J 1))
;                    (END (INDEX+ START NITEMS))
;                    (INDEX 0 (INDEX+ INDEX 1)))
;                   ((INDEX>= J END))
;                (DECLARE (TYPE ARRAY-INDEX J END INDEX))
;                (SETF (AREF DATA J)
;                        (THE CARD8 (FUNCALL TRANSFORM (READ-CARD8 INDEX))))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-VECTOR-CARD8
;     (SETF (AREF XLIB::DATA XLIB::J) (XLIB::READ-CARD8 XLIB::INDEX))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-VECTOR-CARD8-WITH-TRANSFORM
;     (SETF (AREF XLIB::DATA XLIB::J)
;             (FUNCALL XLIB::TRANSFORM (XLIB::READ-CARD8 XLIB::INDEX)))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::READ-VECTOR-CARD8-WITH-TRANSFORM
;            (XLIB::REPLY-BUFFER XLIB::NITEMS XLIB::DATA XLIB::TRANSFORM
;             XLIB::START XLIB::INDEX)
;       (DECLARE (TYPE XLIB::REPLY-BUFFER XLIB::REPLY-BUFFER)
;                (TYPE XLIB:ARRAY-INDEX XLIB::NITEMS XLIB::START XLIB::INDEX)
;                (TYPE VECTOR XLIB::DATA)
;                (OPTIMIZE))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD8) T) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WITH-BUFFER-INPUT (XLIB::REPLY-BUFFER :SIZES (8) :INDEX
;                                   XLIB::INDEX)
;           (DO* (#
;                 #
;                 #)
;                (#)
;             (DECLARE #)
;             (SETF #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1193
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN READ-VECTOR-CARD8-WITH-TRANSFORM
;               (REPLY-BUFFER NITEMS DATA TRANSFORM START INDEX)
;          (DECLARE (TYPE REPLY-BUFFER REPLY-BUFFER)
;                   (TYPE ARRAY-INDEX NITEMS START INDEX)
;                   (TYPE VECTOR DATA)
;                   (OPTIMIZE))
;          (DECLARE (TYPE (FUNCTION (CARD8) T) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WITH-BUFFER-INPUT (REPLY-BUFFER :SIZES (8) :INDEX INDEX)
;              (DO* ((J START (INDEX+ J 1))
;                    (END (INDEX+ START NITEMS))
;                    (INDEX 0 (INDEX+ INDEX 1)))
;                   ((INDEX>= J END))
;                (DECLARE (TYPE ARRAY-INDEX J END INDEX))
;                (SETF (AREF DATA J) (FUNCALL TRANSFORM (READ-CARD8 INDEX)))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-READER READ-SEQUENCE-CARD8
;     (XLIB::DEFINE-SEQUENCE-READER XLIB::READ-SEQUENCE-CARD8 XLIB:CARD8
;                                   (XLIB::READ-LIST-CARD8
;                                    XLIB::READ-LIST-CARD8-WITH-TRANSFORM)
;                                   (XLIB::READ-SIMPLE-ARRAY-CARD8
;                                    XLIB::READ-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM)
;                                   (XLIB::READ-VECTOR-CARD8
;                                    XLIB::READ-VECTOR-CARD8-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> COND IF PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G1294
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-READER READ-SEQUENCE-CARD8 CARD8
;                                (READ-LIST-CARD8 READ-LIST-CARD8-WITH-TRANSFORM)
;                                (READ-SIMPLE-ARRAY-CARD8
;                                 READ-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM)
;                                (READ-VECTOR-CARD8
;                                 READ-VECTOR-CARD8-WITH-TRANSFORM))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-INT8
;     (XLIB::DEFINE-TRANSFORMED-SEQUENCE-READER XLIB::READ-SEQUENCE-INT8 XLIB:INT8
;                                               XLIB::CARD8->INT8
;                                               XLIB::READ-SEQUENCE-CARD8)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> COND IF PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G1369
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-INT8 INT8 CARD8->INT8
;                                            READ-SEQUENCE-CARD8)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-READERS (READ-LIST-CARD16 READ-LIST-CARD16-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-READERS
;      (XLIB::READ-LIST-CARD16 XLIB::READ-LIST-CARD16-WITH-TRANSFORM) XLIB:CARD16
;      16 2 XLIB::READ-CARD16)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1463
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-READERS (READ-LIST-CARD16 READ-LIST-CARD16-WITH-TRANSFORM)
;                             CARD16 16 2 READ-CARD16)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM
;     (DEFUN XLIB::READ-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM
;            (XLIB::REPLY-BUFFER XLIB::NITEMS XLIB::DATA XLIB::TRANSFORM
;             XLIB::START XLIB::INDEX)
;       (DECLARE (TYPE XLIB::REPLY-BUFFER XLIB::REPLY-BUFFER)
;                (TYPE XLIB:ARRAY-INDEX XLIB::NITEMS XLIB::START XLIB::INDEX)
;                (TYPE (SIMPLE-ARRAY XLIB:CARD16 (*)) XLIB::DATA))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD16) XLIB:CARD16) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:CARD16 (*)))
;         (XLIB::WITH-BUFFER-INPUT (XLIB::REPLY-BUFFER :SIZES (16) :INDEX
;                                   XLIB::INDEX)
;           (DO* (#
;                 #
;                 #)
;                (#)
;             (DECLARE #)
;             (SETF #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1521
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN READ-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM
;               (REPLY-BUFFER NITEMS DATA TRANSFORM START INDEX)
;          (DECLARE (TYPE REPLY-BUFFER REPLY-BUFFER)
;                   (TYPE ARRAY-INDEX NITEMS START INDEX)
;                   (TYPE (SIMPLE-ARRAY CARD16 (*)) DATA))
;          (DECLARE (TYPE (FUNCTION (CARD16) CARD16) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY CARD16 (*)))
;            (WITH-BUFFER-INPUT (REPLY-BUFFER :SIZES (16) :INDEX INDEX)
;              (DO* ((J START (INDEX+ J 1))
;                    (END (INDEX+ START NITEMS))
;                    (INDEX 0 (INDEX+ INDEX 2)))
;                   ((INDEX>= J END))
;                (DECLARE (TYPE ARRAY-INDEX J END INDEX))
;                (SETF (AREF DATA J)
;                        (THE CARD16 (FUNCALL TRANSFORM (READ-CARD16 INDEX))))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-VECTOR-CARD16
;     (SETF (AREF XLIB::DATA XLIB::J) (XLIB::READ-CARD16 XLIB::INDEX))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-VECTOR-CARD16-WITH-TRANSFORM
;     (SETF (AREF XLIB::DATA XLIB::J)
;             (FUNCALL XLIB::TRANSFORM (XLIB::READ-CARD16 XLIB::INDEX)))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::READ-VECTOR-CARD16-WITH-TRANSFORM
;            (XLIB::REPLY-BUFFER XLIB::NITEMS XLIB::DATA XLIB::TRANSFORM
;             XLIB::START XLIB::INDEX)
;       (DECLARE (TYPE XLIB::REPLY-BUFFER XLIB::REPLY-BUFFER)
;                (TYPE XLIB:ARRAY-INDEX XLIB::NITEMS XLIB::START XLIB::INDEX)
;                (TYPE VECTOR XLIB::DATA)
;                (OPTIMIZE))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD16) T) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WITH-BUFFER-INPUT (XLIB::REPLY-BUFFER :SIZES (16) :INDEX
;                                   XLIB::INDEX)
;           (DO* (#
;                 #
;                 #)
;                (#)
;             (DECLARE #)
;             (SETF #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1581
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN READ-VECTOR-CARD16-WITH-TRANSFORM
;               (REPLY-BUFFER NITEMS DATA TRANSFORM START INDEX)
;          (DECLARE (TYPE REPLY-BUFFER REPLY-BUFFER)
;                   (TYPE ARRAY-INDEX NITEMS START INDEX)
;                   (TYPE VECTOR DATA)
;                   (OPTIMIZE))
;          (DECLARE (TYPE (FUNCTION (CARD16) T) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WITH-BUFFER-INPUT (REPLY-BUFFER :SIZES (16) :INDEX INDEX)
;              (DO* ((J START (INDEX+ J 1))
;                    (END (INDEX+ START NITEMS))
;                    (INDEX 0 (INDEX+ INDEX 2)))
;                   ((INDEX>= J END))
;                (DECLARE (TYPE ARRAY-INDEX J END INDEX))
;                (SETF (AREF DATA J) (FUNCALL TRANSFORM (READ-CARD16 INDEX)))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-READER READ-SEQUENCE-CARD16
;     (XLIB::DEFINE-SEQUENCE-READER XLIB::READ-SEQUENCE-CARD16 XLIB:CARD16
;                                   (XLIB::READ-LIST-CARD16
;                                    XLIB::READ-LIST-CARD16-WITH-TRANSFORM)
;                                   (XLIB::READ-SIMPLE-ARRAY-CARD16
;                                    XLIB::READ-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM)
;                                   (XLIB::READ-VECTOR-CARD16
;                                    XLIB::READ-VECTOR-CARD16-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> COND IF PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G1611
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-READER READ-SEQUENCE-CARD16 CARD16
;                                (READ-LIST-CARD16
;                                 READ-LIST-CARD16-WITH-TRANSFORM)
;                                (READ-SIMPLE-ARRAY-CARD16
;                                 READ-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM)
;                                (READ-VECTOR-CARD16
;                                 READ-VECTOR-CARD16-WITH-TRANSFORM))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-INT16
;     (XLIB::DEFINE-TRANSFORMED-SEQUENCE-READER XLIB::READ-SEQUENCE-INT16
;                                               XLIB:INT16 XLIB::CARD16->INT16
;                                               XLIB::READ-SEQUENCE-CARD16)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> COND IF PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G1686
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-INT16 INT16
;                                            CARD16->INT16 READ-SEQUENCE-CARD16)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-READERS (READ-LIST-CARD32 READ-LIST-CARD32-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-READERS
;      (XLIB::READ-LIST-CARD32 XLIB::READ-LIST-CARD32-WITH-TRANSFORM) XLIB:CARD32
;      32 4 XLIB::READ-CARD32)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1780
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-READERS (READ-LIST-CARD32 READ-LIST-CARD32-WITH-TRANSFORM)
;                             CARD32 32 4 READ-CARD32)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM
;     (DEFUN XLIB::READ-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM
;            (XLIB::REPLY-BUFFER XLIB::NITEMS XLIB::DATA XLIB::TRANSFORM
;             XLIB::START XLIB::INDEX)
;       (DECLARE (TYPE XLIB::REPLY-BUFFER XLIB::REPLY-BUFFER)
;                (TYPE XLIB:ARRAY-INDEX XLIB::NITEMS XLIB::START XLIB::INDEX)
;                (TYPE (SIMPLE-ARRAY XLIB:CARD32 (*)) XLIB::DATA))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD32) XLIB:CARD32) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:CARD32 (*)))
;         (XLIB::WITH-BUFFER-INPUT (XLIB::REPLY-BUFFER :SIZES (32) :INDEX
;                                   XLIB::INDEX)
;           (DO* (#
;                 #
;                 #)
;                (#)
;             (DECLARE #)
;             (SETF #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1838
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN READ-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM
;               (REPLY-BUFFER NITEMS DATA TRANSFORM START INDEX)
;          (DECLARE (TYPE REPLY-BUFFER REPLY-BUFFER)
;                   (TYPE ARRAY-INDEX NITEMS START INDEX)
;                   (TYPE (SIMPLE-ARRAY CARD32 (*)) DATA))
;          (DECLARE (TYPE (FUNCTION (CARD32) CARD32) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY CARD32 (*)))
;            (WITH-BUFFER-INPUT (REPLY-BUFFER :SIZES (32) :INDEX INDEX)
;              (DO* ((J START (INDEX+ J 1))
;                    (END (INDEX+ START NITEMS))
;                    (INDEX 0 (INDEX+ INDEX 4)))
;                   ((INDEX>= J END))
;                (DECLARE (TYPE ARRAY-INDEX J END INDEX))
;                (SETF (AREF DATA J)
;                        (THE CARD32 (FUNCALL TRANSFORM (READ-CARD32 INDEX))))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-VECTOR-CARD32
;     (SETF (AREF XLIB::DATA XLIB::J) (XLIB::READ-CARD32 XLIB::INDEX))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN READ-VECTOR-CARD32-WITH-TRANSFORM
;     (SETF (AREF XLIB::DATA XLIB::J)
;             (FUNCALL XLIB::TRANSFORM (XLIB::READ-CARD32 XLIB::INDEX)))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::READ-VECTOR-CARD32-WITH-TRANSFORM
;            (XLIB::REPLY-BUFFER XLIB::NITEMS XLIB::DATA XLIB::TRANSFORM
;             XLIB::START XLIB::INDEX)
;       (DECLARE (TYPE XLIB::REPLY-BUFFER XLIB::REPLY-BUFFER)
;                (TYPE XLIB:ARRAY-INDEX XLIB::NITEMS XLIB::START XLIB::INDEX)
;                (TYPE VECTOR XLIB::DATA)
;                (OPTIMIZE))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD32) T) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WITH-BUFFER-INPUT (XLIB::REPLY-BUFFER :SIZES (32) :INDEX
;                                   XLIB::INDEX)
;           (DO* (#
;                 #
;                 #)
;                (#)
;             (DECLARE #)
;             (SETF #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1898
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN READ-VECTOR-CARD32-WITH-TRANSFORM
;               (REPLY-BUFFER NITEMS DATA TRANSFORM START INDEX)
;          (DECLARE (TYPE REPLY-BUFFER REPLY-BUFFER)
;                   (TYPE ARRAY-INDEX NITEMS START INDEX)
;                   (TYPE VECTOR DATA)
;                   (OPTIMIZE))
;          (DECLARE (TYPE (FUNCTION (CARD32) T) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WITH-BUFFER-INPUT (REPLY-BUFFER :SIZES (32) :INDEX INDEX)
;              (DO* ((J START (INDEX+ J 1))
;                    (END (INDEX+ START NITEMS))
;                    (INDEX 0 (INDEX+ INDEX 4)))
;                   ((INDEX>= J END))
;                (DECLARE (TYPE ARRAY-INDEX J END INDEX))
;                (SETF (AREF DATA J) (FUNCALL TRANSFORM (READ-CARD32 INDEX)))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-READER READ-SEQUENCE-CARD32
;     (XLIB::DEFINE-SEQUENCE-READER XLIB::READ-SEQUENCE-CARD32 XLIB:CARD32
;                                   (XLIB::READ-LIST-CARD32
;                                    XLIB::READ-LIST-CARD32-WITH-TRANSFORM)
;                                   (XLIB::READ-SIMPLE-ARRAY-CARD32
;                                    XLIB::READ-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM)
;                                   (XLIB::READ-VECTOR-CARD32
;                                    XLIB::READ-VECTOR-CARD32-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> COND IF PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G1928
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-READER READ-SEQUENCE-CARD32 CARD32
;                                (READ-LIST-CARD32
;                                 READ-LIST-CARD32-WITH-TRANSFORM)
;                                (READ-SIMPLE-ARRAY-CARD32
;                                 READ-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM)
;                                (READ-VECTOR-CARD32
;                                 READ-VECTOR-CARD32-WITH-TRANSFORM))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-INT32
;     (XLIB::DEFINE-TRANSFORMED-SEQUENCE-READER XLIB::READ-SEQUENCE-INT32
;                                               XLIB:INT32 XLIB::CARD32->INT32
;                                               XLIB::READ-SEQUENCE-CARD32)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> COND IF PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G2002
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-TRANSFORMED-SEQUENCE-READER READ-SEQUENCE-INT32 INT32
;                                            CARD32->INT32 READ-SEQUENCE-CARD32)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-TRANSFORMED-SEQUENCE-WRITER WRITE-SEQUENCE-CHAR
;     (XLIB::DEFINE-TRANSFORMED-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-CHAR CHARACTER
;                                               XLIB:CHAR->CARD8
;                                               XLIB::WRITE-SEQUENCE-CARD8)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G2149
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-TRANSFORMED-SEQUENCE-WRITER WRITE-SEQUENCE-CHAR CHARACTER
;                                            CHAR->CARD8 WRITE-SEQUENCE-CARD8)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-WRITERS (WRITE-LIST-CARD8 WRITE-LIST-CARD8-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-WRITERS
;      (XLIB::WRITE-LIST-CARD8 XLIB::WRITE-LIST-CARD8-WITH-TRANSFORM) XLIB:CARD8 1
;      XLIB::WRITE-CARD8)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G2371
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-WRITERS (WRITE-LIST-CARD8 WRITE-LIST-CARD8-WITH-TRANSFORM)
;                             CARD8 1 WRITE-CARD8)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM
;     (DEFUN XLIB::WRITE-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE (SIMPLE-ARRAY XLIB:CARD8 (*)) XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD8) XLIB:CARD8) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:CARD8 (*)))
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD8
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DOTIMES (XLIB::J XLIB::CHUNK)
;             (DECLARE #)
;             (XLIB::WRITE-CARD8 XLIB::J #)
;             (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G2513
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE (SIMPLE-ARRAY CARD8 (*)) DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END))
;          (DECLARE (TYPE (FUNCTION (CARD8) CARD8) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY CARD8 (*)))
;            (WRITING-BUFFER-CHUNKS CARD8
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DOTIMES (J CHUNK)
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CARD8 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CARD8
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CARD8-WITH-TRANSFORM
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::WRITE-VECTOR-CARD8-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE VECTOR XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END))
;       (DECLARE (TYPE (FUNCTION (T) XLIB:CARD8) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD8
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DOTIMES (XLIB::J XLIB::CHUNK)
;             (DECLARE #)
;             (XLIB::WRITE-CARD8 XLIB::J #)
;             (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G2636
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-VECTOR-CARD8-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE VECTOR DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END))
;          (DECLARE (TYPE (FUNCTION (T) CARD8) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WRITING-BUFFER-CHUNKS CARD8
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DOTIMES (J CHUNK)
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CARD8 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CARD8
;     (XLIB::DEFINE-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-CARD8 XLIB:CARD8
;                                   (XLIB::WRITE-LIST-CARD8
;                                    XLIB::WRITE-LIST-CARD8-WITH-TRANSFORM)
;                                   (XLIB::WRITE-SIMPLE-ARRAY-CARD8
;                                    XLIB::WRITE-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM)
;                                   (XLIB::WRITE-VECTOR-CARD8
;                                    XLIB::WRITE-VECTOR-CARD8-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G2734
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CARD8 CARD8
;                                (WRITE-LIST-CARD8
;                                 WRITE-LIST-CARD8-WITH-TRANSFORM)
;                                (WRITE-SIMPLE-ARRAY-CARD8
;                                 WRITE-SIMPLE-ARRAY-CARD8-WITH-TRANSFORM)
;                                (WRITE-VECTOR-CARD8
;                                 WRITE-VECTOR-CARD8-WITH-TRANSFORM))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-TRANSFORMED-SEQUENCE-WRITER WRITE-SEQUENCE-INT8
;     (XLIB::DEFINE-TRANSFORMED-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-INT8 XLIB:INT8
;                                               XLIB::INT8->CARD8
;                                               XLIB::WRITE-SEQUENCE-CARD8)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G2800
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-TRANSFORMED-SEQUENCE-WRITER WRITE-SEQUENCE-INT8 INT8 INT8->CARD8
;                                            WRITE-SEQUENCE-CARD8)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-WRITERS (WRITE-LIST-CARD16 WRITE-LIST-CARD16-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-WRITERS
;      (XLIB::WRITE-LIST-CARD16 XLIB::WRITE-LIST-CARD16-WITH-TRANSFORM) XLIB:CARD16
;      2 XLIB::WRITE-CARD16)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G2945
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-WRITERS
;         (WRITE-LIST-CARD16 WRITE-LIST-CARD16-WITH-TRANSFORM) CARD16 2
;         WRITE-CARD16)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM
;     (DEFUN XLIB::WRITE-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE (SIMPLE-ARRAY XLIB:CARD16 (*)) XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD16) XLIB:CARD16) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:CARD16 (*)))
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD16
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (#) (DECLARE #) (XLIB::WRITE-CARD16 XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3056
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE (SIMPLE-ARRAY CARD16 (*)) DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END))
;          (DECLARE (TYPE (FUNCTION (CARD16) CARD16) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY CARD16 (*)))
;            (WRITING-BUFFER-CHUNKS CARD16
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 2)))
;                  ((INDEX>= J CHUNK))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CARD16 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CARD16
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CARD16-WITH-TRANSFORM
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::WRITE-VECTOR-CARD16-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE VECTOR XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END)
;                (OPTIMIZE))
;       (DECLARE (TYPE (FUNCTION (T) XLIB:CARD16) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD16
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (#) (DECLARE #) (XLIB::WRITE-CARD16 XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3169
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-VECTOR-CARD16-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE VECTOR DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END)
;                   (OPTIMIZE))
;          (DECLARE (TYPE (FUNCTION (T) CARD16) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WRITING-BUFFER-CHUNKS CARD16
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 2)))
;                  ((INDEX>= J CHUNK))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CARD16 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CARD16
;     (XLIB::DEFINE-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-CARD16 XLIB:CARD16
;                                   (XLIB::WRITE-LIST-CARD16
;                                    XLIB::WRITE-LIST-CARD16-WITH-TRANSFORM)
;                                   (XLIB::WRITE-SIMPLE-ARRAY-CARD16
;                                    XLIB::WRITE-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM)
;                                   (XLIB::WRITE-VECTOR-CARD16
;                                    XLIB::WRITE-VECTOR-CARD16-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G3199
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CARD16 CARD16
;                                (WRITE-LIST-CARD16
;                                 WRITE-LIST-CARD16-WITH-TRANSFORM)
;                                (WRITE-SIMPLE-ARRAY-CARD16
;                                 WRITE-SIMPLE-ARRAY-CARD16-WITH-TRANSFORM)
;                                (WRITE-VECTOR-CARD16
;                                 WRITE-VECTOR-CARD16-WITH-TRANSFORM))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-WRITERS (WRITE-LIST-INT16 WRITE-LIST-INT16-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-WRITERS
;      (XLIB::WRITE-LIST-INT16 XLIB::WRITE-LIST-INT16-WITH-TRANSFORM) XLIB:INT16 2
;      XLIB::WRITE-INT16)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3344
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-WRITERS (WRITE-LIST-INT16 WRITE-LIST-INT16-WITH-TRANSFORM)
;                             INT16 2 WRITE-INT16)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-SIMPLE-ARRAY-INT16-WITH-TRANSFORM
;     (DEFUN XLIB::WRITE-SIMPLE-ARRAY-INT16-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE (SIMPLE-ARRAY XLIB:INT16 (*)) XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END))
;       (DECLARE (TYPE (FUNCTION (XLIB:INT16) XLIB:INT16) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:INT16 (*)))
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:INT16
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (#) (DECLARE #) (XLIB::WRITE-INT16 XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3455
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-SIMPLE-ARRAY-INT16-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE (SIMPLE-ARRAY INT16 (*)) DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END))
;          (DECLARE (TYPE (FUNCTION (INT16) INT16) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY INT16 (*)))
;            (WRITING-BUFFER-CHUNKS INT16
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 2)))
;                  ((INDEX>= J CHUNK))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-INT16 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-INT16
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-INT16-WITH-TRANSFORM
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::WRITE-VECTOR-INT16-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE VECTOR XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END)
;                (OPTIMIZE))
;       (DECLARE (TYPE (FUNCTION (T) XLIB:INT16) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:INT16
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (#) (DECLARE #) (XLIB::WRITE-INT16 XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3568
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-VECTOR-INT16-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE VECTOR DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END)
;                   (OPTIMIZE))
;          (DECLARE (TYPE (FUNCTION (T) INT16) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WRITING-BUFFER-CHUNKS INT16
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 2)))
;                  ((INDEX>= J CHUNK))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-INT16 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-INT16
;     (XLIB::DEFINE-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-INT16 XLIB:INT16
;                                   (XLIB::WRITE-LIST-INT16
;                                    XLIB::WRITE-LIST-INT16-WITH-TRANSFORM)
;                                   (XLIB::WRITE-SIMPLE-ARRAY-INT16
;                                    XLIB::WRITE-SIMPLE-ARRAY-INT16-WITH-TRANSFORM)
;                                   (XLIB::WRITE-VECTOR-INT16
;                                    XLIB::WRITE-VECTOR-INT16-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G3598
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-INT16 INT16
;                                (WRITE-LIST-INT16
;                                 WRITE-LIST-INT16-WITH-TRANSFORM)
;                                (WRITE-SIMPLE-ARRAY-INT16
;                                 WRITE-SIMPLE-ARRAY-INT16-WITH-TRANSFORM)
;                                (WRITE-VECTOR-INT16
;                                 WRITE-VECTOR-INT16-WITH-TRANSFORM))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-WRITERS (WRITE-LIST-CARD32 WRITE-LIST-CARD32-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-WRITERS
;      (XLIB::WRITE-LIST-CARD32 XLIB::WRITE-LIST-CARD32-WITH-TRANSFORM) XLIB:CARD32
;      4 XLIB::WRITE-CARD32)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3743
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-WRITERS
;         (WRITE-LIST-CARD32 WRITE-LIST-CARD32-WITH-TRANSFORM) CARD32 4
;         WRITE-CARD32)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-SIMPLE-ARRAY-CARD32
;     (XLIB::WRITE-CARD32 XLIB::J (AREF XLIB::DATA XLIB::INDEX))
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 (AREF XLIB::DATA XLIB::INDEX))
;                      XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET XLIB::J))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM
;     (DEFUN XLIB::WRITE-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE (SIMPLE-ARRAY XLIB:CARD32 (*)) XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD32) XLIB:CARD32) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:CARD32 (*)))
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD32
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (#) (DECLARE #) (XLIB::WRITE-CARD32 XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3854
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE (SIMPLE-ARRAY CARD32 (*)) DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END))
;          (DECLARE (TYPE (FUNCTION (CARD32) CARD32) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY CARD32 (*)))
;            (WRITING-BUFFER-CHUNKS CARD32
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 4)))
;                  ((INDEX>= J CHUNK))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CARD32 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

;     (FUNCALL XLIB::TRANSFORM (AREF XLIB::DATA XLIB::INDEX))
; ==>
;   (SB-C::%FUNCALL (SB-KERNEL:%COERCE-CALLABLE-TO-FUN XLIB::TRANSFORM)
;                   (AREF XLIB::DATA XLIB::INDEX))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CARD32
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CARD32-WITH-TRANSFORM
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::WRITE-VECTOR-CARD32-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE VECTOR XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END)
;                (OPTIMIZE))
;       (DECLARE (TYPE (FUNCTION (T) XLIB:CARD32) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD32
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (#) (DECLARE #) (XLIB::WRITE-CARD32 XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G3967
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-VECTOR-CARD32-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE VECTOR DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END)
;                   (OPTIMIZE))
;          (DECLARE (TYPE (FUNCTION (T) CARD32) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WRITING-BUFFER-CHUNKS CARD32
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 4)))
;                  ((INDEX>= J CHUNK))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CARD32 J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CARD32
;     (XLIB::DEFINE-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-CARD32 XLIB:CARD32
;                                   (XLIB::WRITE-LIST-CARD32
;                                    XLIB::WRITE-LIST-CARD32-WITH-TRANSFORM)
;                                   (XLIB::WRITE-SIMPLE-ARRAY-CARD32
;                                    XLIB::WRITE-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM)
;                                   (XLIB::WRITE-VECTOR-CARD32
;                                    XLIB::WRITE-VECTOR-CARD32-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G3997
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CARD32 CARD32
;                                (WRITE-LIST-CARD32
;                                 WRITE-LIST-CARD32-WITH-TRANSFORM)
;                                (WRITE-SIMPLE-ARRAY-CARD32
;                                 WRITE-SIMPLE-ARRAY-CARD32-WITH-TRANSFORM)
;                                (WRITE-VECTOR-CARD32
;                                 WRITE-VECTOR-CARD32-WITH-TRANSFORM))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-TRANSFORMED-SEQUENCE-WRITER WRITE-SEQUENCE-INT32
;     (XLIB::DEFINE-TRANSFORMED-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-INT32
;                                               XLIB:INT32 XLIB::INT32->CARD32
;                                               XLIB::WRITE-SEQUENCE-CARD32)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G4062
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-TRANSFORMED-SEQUENCE-WRITER WRITE-SEQUENCE-INT32 INT32
;                                            INT32->CARD32 WRITE-SEQUENCE-CARD32)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in:
;      DEFINE-LIST-WRITERS (WRITE-LIST-CHAR2B WRITE-LIST-CHAR2B-WITH-TRANSFORM)
;     (XLIB::DEFINE-LIST-WRITERS
;      (XLIB::WRITE-LIST-CHAR2B XLIB::WRITE-LIST-CHAR2B-WITH-TRANSFORM) XLIB:CARD16
;      2 XLIB::WRITE-CHAR2B)
; --> PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G4313
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-LIST-WRITERS
;         (WRITE-LIST-CHAR2B WRITE-LIST-CHAR2B-WITH-TRANSFORM) CARD16 2
;         WRITE-CHAR2B)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-SIMPLE-ARRAY-CHAR2B-WITH-TRANSFORM
;     (DEFUN XLIB::WRITE-SIMPLE-ARRAY-CHAR2B-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE (SIMPLE-ARRAY XLIB:CARD16 (*)) XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END))
;       (DECLARE (TYPE (FUNCTION (XLIB:CARD16) XLIB:CARD16) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA (SIMPLE-ARRAY XLIB:CARD16 (*)))
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD16
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (# #) (DECLARE #) (XLIB::WRITE-CHAR2B XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G4454
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-SIMPLE-ARRAY-CHAR2B-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE (SIMPLE-ARRAY CARD16 (*)) DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END))
;          (DECLARE (TYPE (FUNCTION (CARD16) CARD16) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA (SIMPLE-ARRAY CARD16 (*)))
;            (WRITING-BUFFER-CHUNKS CARD16
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 2)))
;                  ((INDEX>= J (1- CHUNK)) (SETF CHUNK J))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CHAR2B J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CHAR2B
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFUN WRITE-VECTOR-CHAR2B-WITH-TRANSFORM
;     (AREF XLIB::DATA XLIB::INDEX)
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (DEFUN XLIB::WRITE-VECTOR-CHAR2B-WITH-TRANSFORM
;            (XLIB::BUFFER XLIB::BOFFSET XLIB::DATA XLIB::START XLIB::END
;             XLIB::TRANSFORM)
;       (DECLARE (TYPE XLIB::BUFFER XLIB::BUFFER)
;                (TYPE VECTOR XLIB::DATA)
;                (TYPE XLIB:ARRAY-INDEX XLIB::BOFFSET XLIB::START XLIB::END)
;                (OPTIMIZE))
;       (DECLARE (TYPE (FUNCTION (T) XLIB:CARD16) XLIB::TRANSFORM)
;                (DYNAMIC-EXTENT XLIB::TRANSFORM))
;       (XLIB::WITH-VECTOR (XLIB::DATA VECTOR)
;         (XLIB::WRITING-BUFFER-CHUNKS XLIB:CARD16
;             ((XLIB::INDEX XLIB::START))
;             ((TYPE XLIB:ARRAY-INDEX XLIB::INDEX))
;           (DO (#) (# #) (DECLARE #) (XLIB::WRITE-CHAR2B XLIB::J #) (SETQ #))))
;       NIL)
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G4597
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFUN WRITE-VECTOR-CHAR2B-WITH-TRANSFORM
;               (BUFFER BOFFSET DATA START END TRANSFORM)
;          (DECLARE (TYPE BUFFER BUFFER)
;                   (TYPE VECTOR DATA)
;                   (TYPE ARRAY-INDEX BOFFSET START END)
;                   (OPTIMIZE))
;          (DECLARE (TYPE (FUNCTION (T) CARD16) TRANSFORM)
;                   (DYNAMIC-EXTENT TRANSFORM))
;          (WITH-VECTOR (DATA VECTOR)
;            (WRITING-BUFFER-CHUNKS CARD16
;                ((INDEX START))
;                ((TYPE ARRAY-INDEX INDEX))
;              (DO ((J 0 (INDEX+ J 2)))
;                  ((INDEX>= J (1- CHUNK)) (SETF CHUNK J))
;                (DECLARE (TYPE ARRAY-INDEX J))
;                (WRITE-CHAR2B J (FUNCALL TRANSFORM (AREF DATA INDEX)))
;                (SETQ INDEX (INDEX+ INDEX 1)))))
;          NIL)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/buffer.lisp
; in: DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CHAR2B
;     (XLIB::DEFINE-SEQUENCE-WRITER XLIB::WRITE-SEQUENCE-CHAR2B XLIB:CARD16
;                                   (XLIB::WRITE-LIST-CHAR2B
;                                    XLIB::WRITE-LIST-CHAR2B-WITH-TRANSFORM)
;                                   (XLIB::WRITE-SIMPLE-ARRAY-CHAR2B
;                                    XLIB::WRITE-SIMPLE-ARRAY-CHAR2B-WITH-TRANSFORM)
;                                   (XLIB::WRITE-VECTOR-CHAR2B
;                                    XLIB::WRITE-VECTOR-CHAR2B-WITH-TRANSFORM))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN COND IF COND IF COND IF COND IF 
; --> PROGN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET VALUES PROG1 LET 
; ==>
;   #:G4636
; 
; note: could not stack allocate TRANSFORM in:
;        (DEFINE-SEQUENCE-WRITER WRITE-SEQUENCE-CHAR2B CARD16
;                                (WRITE-LIST-CHAR2B
;                                 WRITE-LIST-CHAR2B-WITH-TRANSFORM)
;                                (WRITE-SIMPLE-ARRAY-CHAR2B
;                                 WRITE-SIMPLE-ARRAY-CHAR2B-WITH-TRANSFORM)
;                                (WRITE-VECTOR-CHAR2B
;                                 WRITE-VECTOR-CHAR2B-WITH-TRANSFORM))
; 
; compilation unit finished
;   printed 80 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/display.lisp
; in: DEFUN WITH-EVENT-QUEUE-FUNCTION
;     (DEFUN XLIB::WITH-EVENT-QUEUE-FUNCTION (XLIB:DISPLAY XLIB::TIMEOUT FUNCTION)
;       (DECLARE (TYPE XLIB:DISPLAY XLIB:DISPLAY)
;                (TYPE (OR NULL NUMBER) XLIB::TIMEOUT)
;                (TYPE FUNCTION FUNCTION)
;                (DYNAMIC-EXTENT FUNCTION)
;                (IGNORABLE XLIB:DISPLAY XLIB::TIMEOUT))
;       (XLIB:WITH-EVENT-QUEUE (XLIB:DISPLAY :TIMEOUT XLIB::TIMEOUT :INLINE T)
;         (FUNCALL FUNCTION)))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G529
; 
; note: could not stack allocate FUNCTION in:
;        (DEFUN WITH-EVENT-QUEUE-FUNCTION (DISPLAY TIMEOUT FUNCTION)
;          (DECLARE (TYPE DISPLAY DISPLAY)
;                   (TYPE (OR NULL NUMBER) TIMEOUT)
;                   (TYPE FUNCTION FUNCTION)
;                   (DYNAMIC-EXTENT FUNCTION)
;                   (IGNORABLE DISPLAY TIMEOUT))
;          (WITH-EVENT-QUEUE (DISPLAY :TIMEOUT TIMEOUT :INLINE T)
;            (FUNCALL FUNCTION)))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/display.lisp
; in: DEFUN DISPLAY-CONNECT
;     (LENGTH XLIB::AUTHORIZATION-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH XLIB::AUTHORIZATION-DATA)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH XLIB::AUTHORIZATION-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; compilation unit finished
;   printed 9 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gcontext.lisp
; in: DEFUN FORCE-GCONTEXT-CHANGES-INTERNAL
;     (LENGTH XLIB::LOCAL-DASH)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-SETDASHES+)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       (XLIB:CARD16 (OR (XLIB::GCONTEXT-INTERNAL-DASH-OFFSET XLIB::LOCAL-STATE) 0)
;        (LENGTH XLIB::LOCAL-DASH))
;       ((SEQUENCE :FORMAT XLIB:CARD8) XLIB::LOCAL-DASH))
; --> LET XLIB::WITH-BUFFER PROGN MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS 
; --> PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET 
; --> LET* XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::LOCAL-DASH)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS VECTOR
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR CONS VECTOR
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (EQL (SVREF XLIB::SERVER-STATE XLIB::I)
;          (SETQ XLIB::LOCAL (SVREF XLIB::LOCAL-STATE XLIB::I)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.

;     (FUNCALL (XLIB::GCONTEXT-EXTENSION-SET-FUNCTION (CAR XLIB::EXTENSION))
;              XLIB:GCONTEXT XLIB::LOCAL)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (XLIB::GCONTEXT-EXTENSION-SET-FUNCTION (CAR XLIB::EXTENSION)))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-SETCLIPRECTANGLES+)
;       (XLIB::DATA (FIRST XLIB::LOCAL-CLIP))
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       (XLIB:CARD16 (OR (XLIB::GCONTEXT-INTERNAL-CLIP-X XLIB::LOCAL-STATE) 0)
;        (OR (XLIB::GCONTEXT-INTERNAL-CLIP-Y XLIB::LOCAL-STATE) 0))
;       ((SEQUENCE :FORMAT XLIB:INT16) (SECOND XLIB::LOCAL-CLIP)))
; --> LET XLIB::WITH-BUFFER PROGN MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS 
; --> PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET 
; --> LET* XLIB::CHECK-PUT LET XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::.VALUE.)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (EQL (SVREF XLIB::SERVER-STATE XLIB::I)
;          (SETQ XLIB::LOCAL (SVREF XLIB::LOCAL-STATE XLIB::I)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

;     (EQL (THE (OR NULL XLIB:CARD32) (SVREF XLIB::SERVER-STATE XLIB::I))
;          (SETQ XLIB::LOCAL
;                  (THE (OR NULL XLIB:CARD32) (SVREF XLIB::LOCAL-STATE XLIB::I))))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (OR NULL (UNSIGNED-BYTE 32)), not a FIXNUM.
;       The second argument is a (OR NULL (UNSIGNED-BYTE 32)), not a FIXNUM.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gcontext.lisp
; in: DEFUN COPY-GCONTEXT-LOCAL-STATE
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:GCONTEXT 'XLIB:GCONTEXT)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER PROGN FUNCALL SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (- XLIB::*GCONTEXT-DATA-LENGTH*)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER XLIB::*GCONTEXT-DATA-LENGTH*))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   Eliminate %negate/%negate of rationals
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (ELT XLIB::*GCONTEXT-EXTENSIONS* XLIB::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

;     (FUNCALL XLIB::COPY-FUNCTION XLIB:GCONTEXT XLIB::TEMP-GC
;              (SVREF XLIB::LOCAL-STATE
;                     (XLIB::INDEX+ XLIB::I XLIB::*GCONTEXT-DATA-LENGTH*)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN XLIB::COPY-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (- XLIB::*GCONTEXT-DATA-LENGTH*)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER XLIB::*GCONTEXT-DATA-LENGTH*))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 32) &REST
;                                                          T).

;     (ASH XLIB::EXTENSION-MASK (- XLIB::*GCONTEXT-DATA-LENGTH*))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 3) because:
;       The second argument is a INTEGER, not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline ASH (cost 3) because:
;       The second argument is a INTEGER, not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       etc.

;     (ASH BIT -1)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gcontext.lisp
; in: DEFUN RESTORE-GCONTEXT-TEMP-STATE
;     (- XLIB::*GCONTEXT-DATA-LENGTH*)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER XLIB::*GCONTEXT-DATA-LENGTH*))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   Eliminate %negate/%negate of rationals
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (FUNCALL XLIB::COPY-FUNCTION XLIB::TEMP-GC XLIB:GCONTEXT
;              (SVREF XLIB::LOCAL-STATE XLIB::I))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN XLIB::COPY-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (- XLIB::*GCONTEXT-DATA-LENGTH*)
; ==>
;   (SB-KERNEL:%NEGATE (THE NUMBER XLIB::*GCONTEXT-DATA-LENGTH*))
; 
; note: forced to do GENERIC-NEGATE (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a (SIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (SIGNED-BYTE 32) &REST
;                                                          T).

;     (ASH XLIB::TEMP-MASK (- XLIB::*GCONTEXT-DATA-LENGTH*))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 3) because:
;       The second argument is a INTEGER, not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline ASH (cost 3) because:
;       The second argument is a INTEGER, not a (UNSIGNED-BYTE 29).
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       etc.

;     (ASH BIT -1)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gcontext.lisp
; in: DEFUN CREATE-GCONTEXT
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:GCONTEXT 'XLIB:GCONTEXT)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (EQL XLIB::LOCAL
;          (THE (OR NULL XLIB:CARD32) (SVREF XLIB::SERVER-STATE XLIB::I)))
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (OR NULL (UNSIGNED-BYTE 32)), not a FIXNUM.
;       The second argument is a (OR NULL (UNSIGNED-BYTE 32)), not a FIXNUM.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gcontext.lisp
; in: DEFUN COPY-GCONTEXT-COMPONENTS
;     (FIND XLIB::KEY XLIB::*GCONTEXT-EXTENSIONS* :KEY
;           #'XLIB::GCONTEXT-EXTENSION-NAME)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

;     (FUNCALL (XLIB::GCONTEXT-EXTENSION-COPY-FUNCTION XLIB::EXTENSION) XLIB::SRC
;              XLIB::DST
;              (SVREF (XLIB::GCONTEXT-LOCAL-STATE XLIB::SRC)
;                     (XLIB::INDEX+
;                      (POSITION XLIB::EXTENSION XLIB::*GCONTEXT-EXTENSIONS*)
;                      XLIB::*GCONTEXT-DATA-LENGTH*)))
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (XLIB::GCONTEXT-EXTENSION-COPY-FUNCTION XLIB::EXTENSION))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (POSITION XLIB::EXTENSION XLIB::*GCONTEXT-EXTENSIONS*)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).
; 
; compilation unit finished
;   printed 33 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DEFUN QUEUE-EVENT
;     (APPLY (SVREF XLIB::*EVENT-SEND-VECTOR* XLIB::EVENT-CODE) XLIB:DISPLAY
;            XLIB::ARGS)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (SVREF XLIB::*EVENT-SEND-VECTOR* XLIB::EVENT-CODE))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in:
;      DECLARE-EVENT (:KEY-PRESS :KEY-RELEASE :BUTTON-PRESS :BUTTON-RELEASE)
;     (XLIB:DECLARE-EVENT (:KEY-PRESS :KEY-RELEASE :BUTTON-PRESS :BUTTON-RELEASE)
;       (XLIB::DATA XLIB::CODE)
;       (XLIB:CARD16 SEQUENCE)
;       ((OR NULL XLIB:CARD32) TIME)
;       (XLIB:WINDOW XLIB::ROOT (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       ((OR NULL XLIB:WINDOW) XLIB::CHILD)
;       (XLIB:INT16 XLIB::ROOT-X XLIB::ROOT-Y XLIB::X XLIB::Y)
;       (XLIB:CARD16 XLIB::STATE)
;       (BOOLEAN XLIB::SAME-SCREEN-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G1910
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT (:KEY-PRESS :KEY-RELEASE :BUTTON-PRESS :BUTTON-RELEASE)
;          (DATA CODE)
;          (CARD16 SEQUENCE)
;          ((OR NULL CARD32) TIME)
;          (WINDOW ROOT (WINDOW EVENT-WINDOW))
;          ((OR NULL WINDOW) CHILD)
;          (INT16 ROOT-X ROOT-Y X Y)
;          (CARD16 STATE)
;          (BOOLEAN SAME-SCREEN-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :MOTION-NOTIFY
;     (XLIB:DECLARE-EVENT :MOTION-NOTIFY
;       ((XLIB::DATA BOOLEAN) XLIB::HINT-P)
;       (XLIB:CARD16 SEQUENCE)
;       ((OR NULL XLIB:CARD32) TIME)
;       (XLIB:WINDOW XLIB::ROOT (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       ((OR NULL XLIB:WINDOW) XLIB::CHILD)
;       (XLIB:INT16 XLIB::ROOT-X XLIB::ROOT-Y XLIB::X XLIB::Y)
;       (XLIB:CARD16 XLIB::STATE)
;       (BOOLEAN XLIB::SAME-SCREEN-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G2101
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :MOTION-NOTIFY
;          ((DATA BOOLEAN) HINT-P)
;          (CARD16 SEQUENCE)
;          ((OR NULL CARD32) TIME)
;          (WINDOW ROOT (WINDOW EVENT-WINDOW))
;          ((OR NULL WINDOW) CHILD)
;          (INT16 ROOT-X ROOT-Y X Y)
;          (CARD16 STATE)
;          (BOOLEAN SAME-SCREEN-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT (:ENTER-NOTIFY :LEAVE-NOTIFY)
;     (XLIB:DECLARE-EVENT (:ENTER-NOTIFY :LEAVE-NOTIFY)
;       ((XLIB::DATA
;         (XLIB::MEMBER8 :ANCESTOR :VIRTUAL :INFERIOR :NONLINEAR
;          :NONLINEAR-VIRTUAL))
;        XLIB::KIND)
;       (XLIB:CARD16 SEQUENCE)
;       ((OR NULL XLIB:CARD32) TIME)
;       (XLIB:WINDOW XLIB::ROOT (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       ((OR NULL XLIB:WINDOW) XLIB::CHILD)
;       (XLIB:INT16 XLIB::ROOT-X XLIB::ROOT-Y XLIB::X XLIB::Y)
;       (XLIB:CARD16 XLIB::STATE)
;       ((XLIB::MEMBER8 :NORMAL :GRAB :UNGRAB) XLIB::MODE)
;       ((BIT 0) XLIB::FOCUS-P)
;       ((BIT 1) XLIB::SAME-SCREEN-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G2258
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT (:ENTER-NOTIFY :LEAVE-NOTIFY)
;          ((DATA
;            (MEMBER8 :ANCESTOR :VIRTUAL :INFERIOR :NONLINEAR
;             :NONLINEAR-VIRTUAL))
;           KIND)
;          (CARD16 SEQUENCE)
;          ((OR NULL CARD32) TIME)
;          (WINDOW ROOT (WINDOW EVENT-WINDOW))
;          ((OR NULL WINDOW) CHILD)
;          (INT16 ROOT-X ROOT-Y X Y)
;          (CARD16 STATE)
;          ((MEMBER8 :NORMAL :GRAB :UNGRAB) MODE)
;          ((BIT 0) FOCUS-P)
;          ((BIT 1) SAME-SCREEN-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT (:FOCUS-IN :FOCUS-OUT)
;     (XLIB:DECLARE-EVENT (:FOCUS-IN :FOCUS-OUT)
;       ((XLIB::DATA
;         (XLIB::MEMBER8 :ANCESTOR :VIRTUAL :INFERIOR :NONLINEAR :NONLINEAR-VIRTUAL
;          :POINTER :POINTER-ROOT :NONE))
;        XLIB::KIND)
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       ((XLIB::MEMBER8 :NORMAL :WHILE-GRABBED :GRAB :UNGRAB) XLIB::MODE))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G2550
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT (:FOCUS-IN :FOCUS-OUT)
;          ((DATA
;            (MEMBER8 :ANCESTOR :VIRTUAL :INFERIOR :NONLINEAR :NONLINEAR-VIRTUAL
;             :POINTER :POINTER-ROOT :NONE))
;           KIND)
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          ((MEMBER8 :NORMAL :WHILE-GRABBED :GRAB :UNGRAB) MODE))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :KEYMAP-NOTIFY
;     (XLIB:DECLARE-EVENT :KEYMAP-NOTIFY
;       ((XLIB::BIT-VECTOR256 0) XLIB::KEYMAP))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G2794
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :KEYMAP-NOTIFY
;          ((BIT-VECTOR256 0) KEYMAP))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :EXPOSURE
;     (XLIB:DECLARE-EVENT :EXPOSURE
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (XLIB:CARD16 XLIB::X XLIB::Y XLIB::WIDTH XLIB::HEIGHT COUNT))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G2878
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :EXPOSURE
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (CARD16 X Y WIDTH HEIGHT COUNT))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :GRAPHICS-EXPOSURE
;     (XLIB:DECLARE-EVENT :GRAPHICS-EXPOSURE
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:DRAWABLE (XLIB:DRAWABLE XLIB::EVENT-WINDOW))
;       (XLIB:CARD16 XLIB::X XLIB::Y XLIB::WIDTH XLIB::HEIGHT)
;       (XLIB:CARD16 XLIB::MINOR)
;       (XLIB:CARD16 COUNT)
;       (XLIB:CARD8 XLIB::MAJOR))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G2977
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :GRAPHICS-EXPOSURE
;          (CARD16 SEQUENCE)
;          (DRAWABLE (DRAWABLE EVENT-WINDOW))
;          (CARD16 X Y WIDTH HEIGHT)
;          (CARD16 MINOR)
;          (CARD16 COUNT)
;          (CARD8 MAJOR))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :NO-EXPOSURE
;     (XLIB:DECLARE-EVENT :NO-EXPOSURE
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:DRAWABLE (XLIB:DRAWABLE XLIB::EVENT-WINDOW))
;       (XLIB:CARD16 XLIB::MINOR)
;       (XLIB:CARD8 XLIB::MAJOR))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3081
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :NO-EXPOSURE
;          (CARD16 SEQUENCE)
;          (DRAWABLE (DRAWABLE EVENT-WINDOW))
;          (CARD16 MINOR)
;          (CARD8 MAJOR))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :VISIBILITY-NOTIFY
;     (XLIB:DECLARE-EVENT :VISIBILITY-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       ((XLIB::MEMBER8 :UNOBSCURED :PARTIALLY-OBSCURED :FULLY-OBSCURED)
;        XLIB::STATE))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3177
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :VISIBILITY-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          ((MEMBER8 :UNOBSCURED :PARTIALLY-OBSCURED :FULLY-OBSCURED) STATE))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :CREATE-NOTIFY
;     (XLIB:DECLARE-EVENT :CREATE-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB::PARENT XLIB::EVENT-WINDOW) XLIB:WINDOW)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (XLIB:CARD16 XLIB::WIDTH XLIB::HEIGHT XLIB::BORDER-WIDTH)
;       (BOOLEAN XLIB::OVERRIDE-REDIRECT-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3336
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :CREATE-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW (PARENT EVENT-WINDOW) WINDOW)
;          (INT16 X Y)
;          (CARD16 WIDTH HEIGHT BORDER-WIDTH)
;          (BOOLEAN OVERRIDE-REDIRECT-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :DESTROY-NOTIFY
;     (XLIB:DECLARE-EVENT :DESTROY-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW XLIB::EVENT-WINDOW XLIB:WINDOW))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3438
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :DESTROY-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW EVENT-WINDOW WINDOW))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :UNMAP-NOTIFY
;     (XLIB:DECLARE-EVENT :UNMAP-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW XLIB::EVENT-WINDOW XLIB:WINDOW)
;       (BOOLEAN XLIB::CONFIGURE-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3522
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :UNMAP-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW EVENT-WINDOW WINDOW)
;          (BOOLEAN CONFIGURE-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :MAP-NOTIFY
;     (XLIB:DECLARE-EVENT :MAP-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW XLIB::EVENT-WINDOW XLIB:WINDOW)
;       (BOOLEAN XLIB::OVERRIDE-REDIRECT-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3614
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :MAP-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW EVENT-WINDOW WINDOW)
;          (BOOLEAN OVERRIDE-REDIRECT-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :MAP-REQUEST
;     (XLIB:DECLARE-EVENT :MAP-REQUEST
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB::PARENT XLIB::EVENT-WINDOW) XLIB:WINDOW))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3706
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :MAP-REQUEST
;          (CARD16 SEQUENCE)
;          (WINDOW (PARENT EVENT-WINDOW) WINDOW))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :REPARENT-NOTIFY
;     (XLIB:DECLARE-EVENT :REPARENT-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW XLIB::EVENT-WINDOW XLIB:WINDOW XLIB::PARENT)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (BOOLEAN XLIB::OVERRIDE-REDIRECT-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3794
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :REPARENT-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW EVENT-WINDOW WINDOW PARENT)
;          (INT16 X Y)
;          (BOOLEAN OVERRIDE-REDIRECT-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :CONFIGURE-NOTIFY
;     (XLIB:DECLARE-EVENT :CONFIGURE-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW XLIB::EVENT-WINDOW XLIB:WINDOW)
;       ((OR NULL XLIB:WINDOW) XLIB::ABOVE-SIBLING)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (XLIB:CARD16 XLIB::WIDTH XLIB::HEIGHT XLIB::BORDER-WIDTH)
;       (BOOLEAN XLIB::OVERRIDE-REDIRECT-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G3909
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :CONFIGURE-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW EVENT-WINDOW WINDOW)
;          ((OR NULL WINDOW) ABOVE-SIBLING)
;          (INT16 X Y)
;          (CARD16 WIDTH HEIGHT BORDER-WIDTH)
;          (BOOLEAN OVERRIDE-REDIRECT-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :CONFIGURE-REQUEST
;     (XLIB:DECLARE-EVENT :CONFIGURE-REQUEST
;       ((XLIB::DATA (XLIB::MEMBER8 :ABOVE :BELOW :TOP-IF :BOTTOM-IF :OPPOSITE))
;        XLIB::STACK-MODE)
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB::PARENT XLIB::EVENT-WINDOW) XLIB:WINDOW)
;       ((OR NULL XLIB:WINDOW) XLIB::ABOVE-SIBLING)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (XLIB:CARD16 XLIB::WIDTH XLIB::HEIGHT XLIB::BORDER-WIDTH XLIB::VALUE-MASK))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G4036
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :CONFIGURE-REQUEST
;          ((DATA (MEMBER8 :ABOVE :BELOW :TOP-IF :BOTTOM-IF :OPPOSITE))
;           STACK-MODE)
;          (CARD16 SEQUENCE)
;          (WINDOW (PARENT EVENT-WINDOW) WINDOW)
;          ((OR NULL WINDOW) ABOVE-SIBLING)
;          (INT16 X Y)
;          (CARD16 WIDTH HEIGHT BORDER-WIDTH VALUE-MASK))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :GRAVITY-NOTIFY
;     (XLIB:DECLARE-EVENT :GRAVITY-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW XLIB::EVENT-WINDOW XLIB:WINDOW)
;       (XLIB:INT16 XLIB::X XLIB::Y))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G4218
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :GRAVITY-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW EVENT-WINDOW WINDOW)
;          (INT16 X Y))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :RESIZE-REQUEST
;     (XLIB:DECLARE-EVENT :RESIZE-REQUEST
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (XLIB:CARD16 XLIB::WIDTH XLIB::HEIGHT))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G4307
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :RESIZE-REQUEST
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (CARD16 WIDTH HEIGHT))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :CIRCULATE-NOTIFY
;     (XLIB:DECLARE-EVENT :CIRCULATE-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW XLIB::EVENT-WINDOW XLIB:WINDOW XLIB::PARENT)
;       ((XLIB::MEMBER8 :TOP :BOTTOM) XLIB::PLACE))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G4398
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :CIRCULATE-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW EVENT-WINDOW WINDOW PARENT)
;          ((MEMBER8 :TOP :BOTTOM) PLACE))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :CIRCULATE-REQUEST
;     (XLIB:DECLARE-EVENT :CIRCULATE-REQUEST
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB::PARENT XLIB::EVENT-WINDOW) XLIB:WINDOW)
;       (XLIB::PAD16 1 2)
;       ((XLIB::MEMBER8 :TOP :BOTTOM) XLIB::PLACE))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G4558
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :CIRCULATE-REQUEST
;          (CARD16 SEQUENCE)
;          (WINDOW (PARENT EVENT-WINDOW) WINDOW)
;          (PAD16 1 2)
;          ((MEMBER8 :TOP :BOTTOM) PLACE))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :PROPERTY-NOTIFY
;     (XLIB:DECLARE-EVENT :PROPERTY-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (KEYWORD ATOM)
;       ((OR NULL XLIB:CARD32) TIME)
;       ((XLIB::MEMBER8 :NEW-VALUE :DELETED) XLIB::STATE))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G4730
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :PROPERTY-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (KEYWORD ATOM)
;          ((OR NULL CARD32) TIME)
;          ((MEMBER8 :NEW-VALUE :DELETED) STATE))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :SELECTION-CLEAR
;     (XLIB:DECLARE-EVENT :SELECTION-CLEAR
;       (XLIB:CARD16 SEQUENCE)
;       ((OR NULL XLIB:CARD32) TIME)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (KEYWORD XLIB::SELECTION))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G4902
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :SELECTION-CLEAR
;          (CARD16 SEQUENCE)
;          ((OR NULL CARD32) TIME)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (KEYWORD SELECTION))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :SELECTION-REQUEST
;     (XLIB:DECLARE-EVENT :SELECTION-REQUEST
;       (XLIB:CARD16 SEQUENCE)
;       ((OR NULL XLIB:CARD32) TIME)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW) XLIB::REQUESTOR)
;       (KEYWORD XLIB::SELECTION XLIB::TARGET)
;       ((OR NULL KEYWORD) XLIB::PROPERTY))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G5018
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :SELECTION-REQUEST
;          (CARD16 SEQUENCE)
;          ((OR NULL CARD32) TIME)
;          (WINDOW (WINDOW EVENT-WINDOW) REQUESTOR)
;          (KEYWORD SELECTION TARGET)
;          ((OR NULL KEYWORD) PROPERTY))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :SELECTION-NOTIFY
;     (XLIB:DECLARE-EVENT :SELECTION-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       ((OR NULL XLIB:CARD32) TIME)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (KEYWORD XLIB::SELECTION XLIB::TARGET)
;       ((OR NULL KEYWORD) XLIB::PROPERTY))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G5142
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :SELECTION-NOTIFY
;          (CARD16 SEQUENCE)
;          ((OR NULL CARD32) TIME)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (KEYWORD SELECTION TARGET)
;          ((OR NULL KEYWORD) PROPERTY))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :COLORMAP-NOTIFY
;     (XLIB:DECLARE-EVENT :COLORMAP-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       ((OR NULL XLIB:COLORMAP) XLIB:COLORMAP)
;       (BOOLEAN XLIB::NEW-P XLIB::INSTALLED-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G5251
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :COLORMAP-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          ((OR NULL COLORMAP) COLORMAP)
;          (BOOLEAN NEW-P INSTALLED-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :CLIENT-MESSAGE
;     (XLIB:DECLARE-EVENT :CLIENT-MESSAGE
;       (XLIB::DATA FORMAT)
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (KEYWORD TYPE)
;       ((XLIB::CLIENT-MESSAGE-SEQUENCE FORMAT) XLIB::DATA))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK 
; --> XLIB::READING-EVENT XLIB::WITH-BUFFER-INPUT LET LET* FUNCALL 
; --> SB-C::%FUNCALL XLIB::CLIENT-MESSAGE-SEQUENCE-GET 
; --> XLIB::CLIENT-MESSAGE-EVENT-GET-SEQUENCE LET* DO BLOCK LET TAGBODY TAGBODY 
; --> CASE LET COND IF PROGN SETF LET* MULTIPLE-VALUE-BIND LET FUNCALL 
; --> SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK 
; --> XLIB::READING-EVENT XLIB::WITH-BUFFER-INPUT LET LET* FUNCALL 
; --> SB-C::%FUNCALL XLIB::CLIENT-MESSAGE-SEQUENCE-GET 
; --> XLIB::CLIENT-MESSAGE-EVENT-GET-SEQUENCE LET* DO BLOCK LET TAGBODY TAGBODY 
; --> CASE LET COND IF COND IF PROGN SETF LET* MULTIPLE-VALUE-BIND LET FUNCALL 
; --> SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK 
; --> XLIB::READING-EVENT XLIB::WITH-BUFFER-INPUT LET LET* FUNCALL 
; --> SB-C::%FUNCALL XLIB::CLIENT-MESSAGE-SEQUENCE-GET 
; --> XLIB::CLIENT-MESSAGE-EVENT-GET-SEQUENCE LET* DO BLOCK LET TAGBODY TAGBODY 
; --> CASE LET COND IF COND IF COND IF PROGN SETF LET* MULTIPLE-VALUE-BIND LET 
; --> FUNCALL SB-C::%FUNCALL (SETF AREF) 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G5384
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :CLIENT-MESSAGE
;          (DATA FORMAT)
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (KEYWORD TYPE)
;          ((CLIENT-MESSAGE-SEQUENCE FORMAT) DATA))

; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CLIENT-MESSAGE-SEQUENCE-PUT 
; --> XLIB::CLIENT-MESSAGE-EVENT-PUT-SEQUENCE ECASE LET COND IF PROGN 
; --> XLIB::SEQUENCE-PUT XLIB::WRITE-SEQUENCE-CARD8 MIN LET 
; ==>
;   (LENGTH XLIB::DATA)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CLIENT-MESSAGE-SEQUENCE-PUT 
; --> XLIB::CLIENT-MESSAGE-EVENT-PUT-SEQUENCE ECASE LET COND IF COND IF PROGN 
; --> XLIB::SEQUENCE-PUT XLIB::WRITE-SEQUENCE-CARD16 MIN LET 
; ==>
;   (LENGTH XLIB::DATA)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CLIENT-MESSAGE-SEQUENCE-PUT 
; --> XLIB::CLIENT-MESSAGE-EVENT-PUT-SEQUENCE ECASE LET COND IF COND IF COND IF 
; --> PROGN XLIB::SEQUENCE-PUT XLIB::WRITE-SEQUENCE-CARD32 MIN LET 
; ==>
;   (LENGTH XLIB::DATA)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DECLARE-EVENT :MAPPING-NOTIFY
;     (XLIB:DECLARE-EVENT :MAPPING-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       ((XLIB::MEMBER8 :MODIFIER :KEYBOARD :POINTER) XLIB::REQUEST)
;       (XLIB:CARD8 XLIB::START)
;       (XLIB:CARD8 COUNT))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G5502
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :MAPPING-NOTIFY
;          (CARD16 SEQUENCE)
;          ((MEMBER8 :MODIFIER :KEYBOARD :POINTER) REQUEST)
;          (CARD8 START)
;          (CARD8 COUNT))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/input.lisp
; in: DEFUN MAKE-ERROR
;     (FUNCALL XLIB::ERROR-DECODE-FUNCTION XLIB:DISPLAY XLIB::EVENT)
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN XLIB::ERROR-DECODE-FUNCTION)
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function
; 
; compilation unit finished
;   printed 42 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN CREATE-WINDOW
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:WINDOW 'XLIB:WINDOW)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-CREATEWINDOW+)
;       (XLIB::DATA XLIB::DEPTH)
;       (XLIB:RESOURCE-ID XLIB::WID)
;       (XLIB:WINDOW XLIB::PARENT)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (XLIB:CARD16 XLIB::WIDTH XLIB::HEIGHT XLIB::BORDER-WIDTH)
;       ((XLIB::MEMBER16 :COPY :INPUT-OUTPUT :INPUT-ONLY) CLASS)
;       (XLIB:RESOURCE-ID
;        (COND ((EQ XLIB::VISUAL :COPY) 0)
;              ((TYPEP XLIB::VISUAL 'XLIB:RESOURCE-ID) XLIB::VISUAL)
;              (T (XLIB:VISUAL-INFO-ID XLIB::VISUAL))))
;       (XLIB::MASK
;        (XLIB:CARD32 XLIB::BACK-PIXMAP XLIB::BACK-PIXEL XLIB::BORDER-PIXMAP
;         XLIB::BORDER-PIXEL)
;        ((XLIB::MEMBER-VECTOR XLIB::+BIT-GRAVITY-VECTOR+) XLIB:BIT-GRAVITY)
;        ((XLIB::MEMBER-VECTOR XLIB::+WIN-GRAVITY-VECTOR+) XLIB::GRAVITY)
;        ((MEMBER :NOT-USEFUL :WHEN-MAPPED :ALWAYS) XLIB::BACKING-STORE)
;        (XLIB:CARD32 XLIB::BACKING-PLANES XLIB::BACKING-PIXEL)
;        ((MEMBER :OFF :ON) XLIB::OVERRIDE-REDIRECT XLIB::SAVE-UNDER)
;        (XLIB:CARD32 XLIB:EVENT-MASK XLIB::DO-NOT-PROPAGATE-MASK)
;        ((OR (MEMBER :COPY) XLIB:COLORMAP) XLIB:COLORMAP)
;        ((OR (MEMBER :NONE) XLIB:CURSOR) XLIB:CURSOR)))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* LET 
; --> UNLESS IF PROGN SETQ THE 
; ==>
;   (LOGIOR XLIB::%MASK 2)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 4)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 8)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 16)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 32)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 64)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 128)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 256)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 512)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 1024)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 2048)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 4096)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 8192)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 16384)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN SEND-EVENT
;     (APPLY (SVREF XLIB::*EVENT-SEND-VECTOR* XLIB::INTERNAL-EVENT-CODE)
;            XLIB:DISPLAY XLIB::ARGS)
; --> MULTIPLE-VALUE-CALL 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN
;    (SVREF XLIB::*EVENT-SEND-VECTOR* XLIB::INTERNAL-EVENT-CODE))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN CREATE-PIXMAP
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:PIXMAP 'XLIB:PIXMAP)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN CREATE-COLORMAP
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:COLORMAP 'XLIB:COLORMAP)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN COPY-COLORMAP-AND-FREE
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB::NEW-COLORMAP 'XLIB:COLORMAP)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN FREE-COLORS
;     (XLIB::WITH-BUFFER-REQUEST ((XLIB:COLORMAP-DISPLAY XLIB:COLORMAP)
;                                 XLIB::+X-FREECOLORS+)
;       (XLIB:COLORMAP XLIB:COLORMAP)
;       (XLIB:CARD32 XLIB::PLANE-MASK)
;       (SEQUENCE XLIB::PIXELS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::PIXELS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN QUERY-COLORS
;     (XLIB::WITH-BUFFER-REQUEST-AND-REPLY (XLIB:DISPLAY XLIB::+X-QUERYCOLORS+ NIL
;                                           :SIZES (8 16))
;         ((XLIB:COLORMAP XLIB:COLORMAP) (SEQUENCE XLIB::PIXELS))
;       (LET ((SEQUENCE (MAKE-SEQUENCE XLIB::RESULT-TYPE #)))
;         (XLIB::ADVANCE-BUFFER-OFFSET XLIB::+REPLYSIZE+)
;         (DOTIMES (XLIB::I (LENGTH SEQUENCE) SEQUENCE)
;           (SETF # #)
;           (XLIB::ADVANCE-BUFFER-OFFSET 8))))
; --> LET UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> BLOCK SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN XLIB::WITH-BUFFER MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK XLIB::WITHOUT-ABORTS PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::PIXELS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a VECTOR.

;     (SETF (ELT SEQUENCE XLIB::I)
;             (XLIB:MAKE-COLOR :RED (XLIB::RGB-VAL-GET 0) :GREEN
;                              (XLIB::RGB-VAL-GET 2) :BLUE (XLIB::RGB-VAL-GET 4)))
; ==>
;   (SB-KERNEL:%SETELT SEQUENCE XLIB::I
;                      (XLIB:MAKE-COLOR :RED (XLIB::RGB-VAL-GET 0) :GREEN
;                                       (XLIB::RGB-VAL-GET 2) :BLUE
;                                       (XLIB::RGB-VAL-GET 4)))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a LIST.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN CREATE-CURSOR
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:CURSOR 'XLIB:CURSOR)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN CREATE-GLYPH-CURSOR
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:CURSOR 'XLIB:CURSOR)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN CHANGE-KEYBOARD-CONTROL
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-CHANGEKEYBOARDCONTROL+
;                                 :SIZES (32))
;       (XLIB::MASK
;        (INTEGER XLIB::KEY-CLICK-PERCENT XLIB::BELL-PERCENT XLIB::BELL-PITCH
;         XLIB::BELL-DURATION)
;        (XLIB:CARD32 XLIB::LED) ((MEMBER :OFF :ON) XLIB::LED-MODE)
;        (XLIB:CARD32 XLIB::KEY)
;        ((MEMBER :OFF :ON :DEFAULT) XLIB::AUTO-REPEAT-MODE)))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* LET 
; --> UNLESS IF PROGN SETQ THE 
; ==>
;   (LOGIOR XLIB::%MASK 2)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 4)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 8)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 16)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 32)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 64)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGIOR XLIB::%MASK 128)
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN SET-POINTER-MAPPING
;     (LENGTH MAP)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (XLIB::WITH-BUFFER-REQUEST-AND-REPLY (XLIB:DISPLAY
;                                           XLIB::+X-SETPOINTERMAPPING+ 2 :SIZES 8)
;         ((XLIB::DATA (LENGTH MAP)) ((SEQUENCE :FORMAT XLIB:CARD8) MAP))
;       (VALUES (XLIB::BOOLEAN-GET 1)))
; --> LET UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> BLOCK SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN XLIB::WITH-BUFFER MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK XLIB::WITHOUT-ABORTS PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH MAP)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN CHANGE-ACCESS-HOST
;     (LENGTH XLIB::ADDRESS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-CHANGEHOSTS+)
;       ((XLIB::DATA BOOLEAN) XLIB::REMOVE-P)
;       (XLIB:CARD8
;        (XLIB::ENCODE-TYPE (OR NULL (MEMBER :INTERNET :DECNET :CHAOS) XLIB:CARD32)
;                           XLIB::FAMILY))
;       (XLIB:CARD16 (LENGTH XLIB::ADDRESS))
;       ((SEQUENCE :FORMAT XLIB:CARD8) XLIB::ADDRESS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::ADDRESS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/requests.lisp
; in: DEFUN ACCESS-HOSTS
;     (SETF (ELT SEQUENCE XLIB::I)
;             (CONS
;              (IF (< XLIB::FAMILY 3)
;                  (SVREF '# XLIB::FAMILY)
;                  XLIB::FAMILY)
;              (XLIB::SEQUENCE-GET :LENGTH XLIB::LEN :FORMAT XLIB:CARD8
;                                  :RESULT-TYPE 'LIST :INDEX
;                                  (+ XLIB::BUFFER-BOFFSET 4))))
; ==>
;   (SB-KERNEL:%SETELT SEQUENCE XLIB::I
;                      (CONS
;                       (IF (< XLIB::FAMILY 3)
;                           (SVREF '#(:INTERNET :DECNET :CHAOS) XLIB::FAMILY)
;                           XLIB::FAMILY)
;                       (XLIB::SEQUENCE-GET :LENGTH XLIB::LEN :FORMAT XLIB:CARD8
;                                           :RESULT-TYPE 'LIST :INDEX
;                                           (+ XLIB::BUFFER-BOFFSET 4))))
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a (SIMPLE-ARRAY
;                                                                    * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR (SIMPLE-ARRAY * (*)) CONS NULL
;                               SB-KERNEL:EXTENDED-SEQUENCE), not a LIST.
; 
; compilation unit finished
;   printed 46 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/fonts.lisp
; in: DEFUN OPEN-FONT
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:FONT 'XLIB:FONT)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/fonts.lisp
; in: DEFUN OPEN-FONT-INTERNAL
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY XLIB:FONT 'XLIB:FONT)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK LET FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

;     (LENGTH XLIB::NAME-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a VECTOR.

;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-OPENFONT+)
;       (XLIB:RESOURCE-ID XLIB::ID)
;       (XLIB:CARD16 (LENGTH XLIB::NAME-STRING))
;       (XLIB::PAD16 NIL)
;       (STRING XLIB::NAME-STRING))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::STRING-PUT LET 
; ==>
;   (LENGTH XLIB::NAME-STRING)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (OR NULL (VECTOR CHARACTER) (VECTOR NIL)
;                               BASE-STRING), not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/fonts.lisp
; in: DEFUN SET-FONT-PATH
;     (ELT XLIB::PATHS XLIB::I)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a LIST.

;     (CEILING XLIB::REQUEST-LENGTH 4)
; --> LET 
; ==>
;   (+ SB-C::X 3)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 8), not a FIXNUM.
;       The result is a (VALUES (INTEGER 11) &OPTIONAL), not a (VALUES FIXNUM
;                                                                      &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 8), not a FIXNUM.
;       The result is a (VALUES (INTEGER 11) &OPTIONAL), not a (VALUES FIXNUM
;                                                                      &REST T).
;       etc.

; --> LET VALUES 
; ==>
;   (ASH SB-C::X -2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (INTEGER 11), not a FIXNUM.
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a (INTEGER 11), not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES (INTEGER 2) &OPTIONAL), not a (VALUES
;                                                              (UNSIGNED-BYTE 32)
;                                                              &REST T).
;       etc.
; 
; compilation unit finished
;   printed 10 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN DRAW-POINTS
;     (XLIB::WITH-BUFFER-REQUEST ((XLIB:DRAWABLE-DISPLAY XLIB:DRAWABLE)
;                                 XLIB::+X-POLYPOINT+ :GC-FORCE XLIB:GCONTEXT)
;       ((XLIB::DATA BOOLEAN) XLIB::RELATIVE-P)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::POINTS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::POINTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN DRAW-LINES
;     (XLIB::WITH-BUFFER-REQUEST ((XLIB:DRAWABLE-DISPLAY XLIB:DRAWABLE)
;                                 XLIB::+X-POLYLINE+ :GC-FORCE XLIB:GCONTEXT)
;       ((XLIB::DATA BOOLEAN) XLIB::RELATIVE-P)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::POINTS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::POINTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN FILL-POLYGON
;     (XLIB::WITH-BUFFER-REQUEST ((XLIB:DRAWABLE-DISPLAY XLIB:DRAWABLE)
;                                 XLIB::+X-FILLPOLY+ :GC-FORCE XLIB:GCONTEXT)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       ((XLIB::MEMBER8 :COMPLEX :NON-CONVEX :CONVEX) XLIB::SHAPE)
;       (BOOLEAN XLIB::RELATIVE-P)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::POINTS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::POINTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN DRAW-SEGMENTS
;     (XLIB::WITH-BUFFER-REQUEST ((XLIB:DRAWABLE-DISPLAY XLIB:DRAWABLE)
;                                 XLIB::+X-POLYSEGMENT+ :GC-FORCE XLIB:GCONTEXT)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::SEGMENTS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::SEGMENTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN DRAW-RECTANGLES
;     (XLIB::WITH-BUFFER-REQUEST ((XLIB:DRAWABLE-DISPLAY XLIB:DRAWABLE)
;                                 (IF XLIB::FILL-P
;                                     XLIB::+X-POLYFILLRECTANGLE+
;                                     XLIB::+X-POLYRECTANGLE+)
;                                 :GC-FORCE XLIB:GCONTEXT)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::RECTANGLES))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::RECTANGLES)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN DRAW-ARCS-VECTOR
;     (AREF XLIB::ARCS (XLIB::INDEX+ XLIB::N 0))
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (AREF XLIB::ARCS (XLIB::INDEX+ XLIB::N 1))
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (AREF XLIB::ARCS (XLIB::INDEX+ XLIB::N 2))
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (AREF XLIB::ARCS (XLIB::INDEX+ XLIB::N 3))
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (AREF XLIB::ARCS (XLIB::INDEX+ XLIB::N 4))
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

;     (AREF XLIB::ARCS (XLIB::INDEX+ XLIB::N 5))
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a VECTOR, not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN PUT-RAW-IMAGE
;     (XLIB::WITH-BUFFER-REQUEST ((XLIB:DRAWABLE-DISPLAY XLIB:DRAWABLE)
;                                 XLIB::+X-PUTIMAGE+ :GC-FORCE XLIB:GCONTEXT)
;       ((XLIB::DATA (MEMBER :BITMAP :XY-PIXMAP :Z-PIXMAP)) FORMAT)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       (XLIB:CARD16 XLIB::WIDTH XLIB::HEIGHT)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (XLIB:CARD8 XLIB::LEFT-PAD XLIB::DEPTH)
;       (XLIB::PAD16 NIL)
;       ((SEQUENCE :FORMAT XLIB:CARD8 :START XLIB::START) XLIB::DATA))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::DATA)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/graphics.lisp
; in: DEFUN GET-RAW-IMAGE
;     (* 4 (XLIB::CARD32-GET 4))
; --> * 
; ==>
;   (ASH SB-C::X 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 17179869181) &OPTIONAL), not a (VALUES
;                                                                    FIXNUM &REST
;                                                                    T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 17179869181) &OPTIONAL), not a (VALUES
;                                                                    (UNSIGNED-BYTE
;                                                                     32)
;                                                                    &REST T).
;       etc.
; 
; compilation unit finished
;   printed 25 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN TEXT-EXTENTS
;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN TEXT-WIDTH
;     (LENGTH SEQUENCE)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN DRAW-GLYPH
;     (LDB (BYTE 8 8) ELT)
; --> SB-KERNEL:%LDB LOGAND 
; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN DRAW-GLYPHS8
;     (DEFUN XLIB::DRAW-GLYPHS8
;            (XLIB:DRAWABLE XLIB:GCONTEXT XLIB::X XLIB::Y SEQUENCE XLIB::START
;             XLIB::END XLIB::TRANSLATE XLIB::WIDTH)
;       (DECLARE (TYPE XLIB:DRAWABLE XLIB:DRAWABLE)
;                (TYPE XLIB:GCONTEXT XLIB:GCONTEXT)
;                (TYPE XLIB:INT16 XLIB::X XLIB::Y)
;                (TYPE XLIB:ARRAY-INDEX XLIB::START)
;                (TYPE SEQUENCE SEQUENCE)
;                (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::END)
;                (TYPE (OR NULL XLIB:INT32) XLIB::WIDTH))
;       (DECLARE
;        (XLIB::CLX-VALUES (OR NULL XLIB:ARRAY-INDEX) (OR NULL XLIB:INT32)))
;       (DECLARE (TYPE XLIB:TRANSLATION-FUNCTION XLIB::TRANSLATE)
;                (DYNAMIC-EXTENT XLIB::TRANSLATE))
;       (LET* ((XLIB::SRC-START XLIB::START)
;              (XLIB::SRC-END (OR XLIB::END #))
;              (XLIB::NEXT-START NIL)
;              (LENGTH (XLIB::INDEX- XLIB::SRC-END XLIB::SRC-START))
;              (XLIB::REQUEST-LENGTH (* LENGTH 2))
;              (XLIB:DISPLAY (XLIB:GCONTEXT-DISPLAY XLIB:GCONTEXT))
;              (XLIB:FONT (XLIB:GCONTEXT-FONT XLIB:GCONTEXT NIL)))
;         (DECLARE (TYPE XLIB:ARRAY-INDEX XLIB::SRC-START XLIB::SRC-END LENGTH)
;                  (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::NEXT-START)
;                  (TYPE XLIB:DISPLAY XLIB:DISPLAY))
;         (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-POLYTEXT8+ :GC-FORCE
;                                     XLIB:GCONTEXT :LENGTH XLIB::REQUEST-LENGTH)
;           (XLIB:DRAWABLE XLIB:DRAWABLE)
;           (XLIB:GCONTEXT XLIB:GCONTEXT)
;           (XLIB:INT16 XLIB::X XLIB::Y)
;           (PROGN
;            (XLIB::WITH-BUFFER-FLUSH-INHIBITED #
;              #)))
;         (VALUES XLIB::NEXT-START XLIB::WIDTH)))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1043
; 
; note: could not stack allocate TRANSLATE in:
;        (DEFUN DRAW-GLYPHS8
;               (DRAWABLE GCONTEXT X Y SEQUENCE START END TRANSLATE WIDTH)
;          (DECLARE (TYPE DRAWABLE DRAWABLE)
;                   (TYPE GCONTEXT GCONTEXT)
;                   (TYPE INT16 X Y)
;                   (TYPE ARRAY-INDEX START)
;                   (TYPE SEQUENCE SEQUENCE)
;                   (TYPE (OR NULL ARRAY-INDEX) END)
;                   (TYPE (OR NULL INT32) WIDTH))
;          (DECLARE (CLX-VALUES (OR NULL ARRAY-INDEX) (OR NULL INT32)))
;          (DECLARE (TYPE TRANSLATION-FUNCTION TRANSLATE)
;                   (DYNAMIC-EXTENT TRANSLATE))
;          (LET* ((SRC-START START)
;                 (SRC-END (OR END (LENGTH SEQUENCE)))
;                 (NEXT-START NIL)
;                 (LENGTH (INDEX- SRC-END SRC-START))
;                 (REQUEST-LENGTH (* LENGTH 2))
;                 (DISPLAY (GCONTEXT-DISPLAY GCONTEXT))
;                 (FONT (GCONTEXT-FONT GCONTEXT NIL)))
;            (DECLARE (TYPE ARRAY-INDEX SRC-START SRC-END LENGTH)
;                     (TYPE (OR NULL ARRAY-INDEX) NEXT-START)
;                     (TYPE DISPLAY DISPLAY))
;            (WITH-BUFFER-REQUEST (DISPLAY +X-POLYTEXT8+ :GC-FORCE GCONTEXT
;                                  :LENGTH REQUEST-LENGTH)
;              (DRAWABLE DRAWABLE)
;              (GCONTEXT GCONTEXT)
;              (INT16 X Y)
;              (PROGN
;               (WITH-BUFFER-FLUSH-INHIBITED (DISPLAY)
;                 (DO* ((BOFFSET (INDEX+ BUFFER-BOFFSET 16))
;                       (SRC-CHUNK 0)
;                       (DST-CHUNK 0)
;                       (OFFSET 0)
;                       (OVERALL-WIDTH 0)
;                       (STOP-P NIL))
;                      ((OR STOP-P (ZEROP LENGTH))
;                       (DO ((END (THE ARRAY-INDEX (LROUND BOFFSET))))
;                           ((INDEX>= BOFFSET END))
;                         (SETF (AREF BUFFER-BBUF BOFFSET) 0)
;                         (INDEX-INCF BOFFSET))
;                       (LENGTH-PUT 2
;                                   (INDEX-ASH (INDEX- BOFFSET BUFFER-BOFFSET)
;                                              -2))
;                       (SETF (BUFFER-BOFFSET DISPLAY) BOFFSET)
;                       (UNLESS (INDEX-ZEROP LENGTH) (SETQ NEXT-START SRC-START))
;                       (WHEN OVERALL-WIDTH (SETQ WIDTH OVERALL-WIDTH)))
;                   (DECLARE (TYPE ARRAY-INDEX SRC-CHUNK DST-CHUNK OFFSET)
;                            (TYPE (OR NULL INT32) OVERALL-WIDTH)
;                            (TYPE GENERALIZED-BOOLEAN STOP-P))
;                   (SETQ SRC-CHUNK (INDEX-MIN LENGTH *MAX-STRING-SIZE*))
;                   (MULTIPLE-VALUE-BIND (NEW-START NEW-FONT TRANSLATED-WIDTH)
;                       (FUNCALL TRANSLATE SEQUENCE SRC-START
;                                (INDEX+ SRC-START SRC-CHUNK) FONT BUFFER-BBUF
;                                (INDEX+ BOFFSET 2))
;                     (SETQ DST-CHUNK (INDEX- NEW-START SRC-START)
;                           LENGTH (INDEX- LENGTH DST-CHUNK)
;                           SRC-START NEW-START)
;                     (IF TRANSLATED-WIDTH
;                         (WHEN OVERALL-WIDTH
;                           (INCF OVERALL-WIDTH TRANSLATED-WIDTH))
;                         (SETQ OVERALL-WIDTH NIL))
;                     (WHEN (INDEX-PLUSP DST-CHUNK)
;                       (SETF (AREF BUFFER-BBUF BOFFSET) DST-CHUNK)
;                       (SETF (AREF BUFFER-BBUF (INDEX+ BOFFSET 1)) OFFSET)
;                       (INCF BOFFSET (INDEX+ DST-CHUNK 2)))
;                     (SETQ OFFSET 0)
;                     (COND
;                      ((NULL NEW-FONT)
;                       (UNLESS (INDEX= SRC-CHUNK DST-CHUNK) (SETQ STOP-P T)))
;                      ((INTEGERP NEW-FONT) (SETQ OFFSET NEW-FONT))
;                      ((TYPE? NEW-FONT 'FONT) (SETQ FONT NEW-FONT)
;                       (LET ((FONT-ID (FONT-ID FONT)) (BUFFER-BOFFSET BOFFSET))
;                         (DECLARE (TYPE RESOURCE-ID FONT-ID)
;                                  (TYPE ARRAY-INDEX BUFFER-BOFFSET))
;                         (LET ((LOCAL-STATE (GCONTEXT-LOCAL-STATE GCONTEXT))
;                               (SERVER-STATE (GCONTEXT-SERVER-STATE GCONTEXT)))
;                           (DECLARE
;                            (TYPE GCONTEXT-STATE LOCAL-STATE SERVER-STATE))
;                           (SETF (GCONTEXT-INTERNAL-FONT-OBJ SERVER-STATE) FONT
;                                 (GCONTEXT-INTERNAL-FONT SERVER-STATE) FONT-ID)
;                           (WITHOUT-INTERRUPTS
;                             (SETF (GCONTEXT-INTERNAL-FONT-OBJ LOCAL-STATE) FONT
;                                   (GCONTEXT-INTERNAL-FONT LOCAL-STATE)
;                                     FONT-ID)))
;                         (CARD8-PUT 0 255)
;                         (CARD8-PUT 1 (LDB (BYTE 8 24) FONT-ID))
;                         (CARD8-PUT 2 (LDB (BYTE 8 16) FONT-ID))
;                         (CARD8-PUT 3 (LDB (BYTE 8 8) FONT-ID))
;                         (CARD8-PUT 4 (LDB (BYTE 8 0) FONT-ID)))
;                       (INDEX-INCF BOFFSET 5))))))))
;            (VALUES NEXT-START WIDTH)))

;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-POLYTEXT8+ :GC-FORCE
;                                 XLIB:GCONTEXT :LENGTH XLIB::REQUEST-LENGTH)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (PROGN
;        (XLIB::WITH-BUFFER-FLUSH-INHIBITED (XLIB:DISPLAY)
;          (DO* (#
;                #
;                #
;                #
;                #
;                #)
;               (# # # # # #)
;            (DECLARE #
;                     #
;                     #)
;            (SETQ #)
;            (MULTIPLE-VALUE-BIND # # # # # # #)))))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME SB-THREAD::WITH-RECURSIVE-LOCK-THUNK
;        :%DEBUG-NAME (FLET SB-THREAD::WITH-RECURSIVE-LOCK-THUNK :IN XLIB::DRAW-GLYPHS8)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS NIL {E78E2F1}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

;     (INCF XLIB::BOFFSET (XLIB::INDEX+ XLIB::DST-CHUNK 2))
; --> LET* 
; ==>
;   (SETQ XLIB::BOFFSET #:NEW977)
; 
; note: doing signed word to integer coercion (cost 20) to BOFFSET

;     (INCF XLIB::OVERALL-WIDTH XLIB::TRANSLATED-WIDTH)
; --> LET* 
; ==>
;   (SETQ XLIB::OVERALL-WIDTH #:NEW968)
; 
; note: doing signed word to integer coercion (cost 20) to OVERALL-WIDTH

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN DRAW-GLYPHS16
;     (DEFUN XLIB::DRAW-GLYPHS16
;            (XLIB:DRAWABLE XLIB:GCONTEXT XLIB::X XLIB::Y SEQUENCE XLIB::START
;             XLIB::END XLIB::TRANSLATE XLIB::WIDTH)
;       (DECLARE (TYPE XLIB:DRAWABLE XLIB:DRAWABLE)
;                (TYPE XLIB:GCONTEXT XLIB:GCONTEXT)
;                (TYPE XLIB:INT16 XLIB::X XLIB::Y)
;                (TYPE XLIB:ARRAY-INDEX XLIB::START)
;                (TYPE SEQUENCE SEQUENCE)
;                (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::END)
;                (TYPE (OR NULL XLIB:INT32) XLIB::WIDTH))
;       (DECLARE
;        (XLIB::CLX-VALUES (OR NULL XLIB:ARRAY-INDEX) (OR NULL XLIB:INT32)))
;       (DECLARE (TYPE XLIB:TRANSLATION-FUNCTION XLIB::TRANSLATE)
;                (DYNAMIC-EXTENT XLIB::TRANSLATE))
;       (LET* ((XLIB::SRC-START XLIB::START)
;              (XLIB::SRC-END (OR XLIB::END #))
;              (XLIB::NEXT-START NIL)
;              (LENGTH (XLIB::INDEX- XLIB::SRC-END XLIB::SRC-START))
;              (XLIB::REQUEST-LENGTH (* LENGTH 3))
;              (XLIB:DISPLAY (XLIB:GCONTEXT-DISPLAY XLIB:GCONTEXT))
;              (XLIB:FONT (XLIB:GCONTEXT-FONT XLIB:GCONTEXT NIL))
;              (XLIB::BUFFER (XLIB::DISPLAY-TBUF16 XLIB:DISPLAY)))
;         (DECLARE (TYPE XLIB:ARRAY-INDEX XLIB::SRC-START XLIB::SRC-END LENGTH)
;                  (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::NEXT-START)
;                  (TYPE XLIB:DISPLAY XLIB:DISPLAY)
;                  (TYPE XLIB::BUFFER-TEXT16 XLIB::BUFFER))
;         (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-POLYTEXT16+ :GC-FORCE
;                                     XLIB:GCONTEXT :LENGTH XLIB::REQUEST-LENGTH)
;           (XLIB:DRAWABLE XLIB:DRAWABLE)
;           (XLIB:GCONTEXT XLIB:GCONTEXT)
;           (XLIB:INT16 XLIB::X XLIB::Y)
;           (PROGN
;            (XLIB::WITH-BUFFER-FLUSH-INHIBITED #
;              #)))
;         (VALUES XLIB::NEXT-START XLIB::WIDTH)))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL 
; ==>
;   #:G1249
; 
; note: could not stack allocate TRANSLATE in:
;        (DEFUN DRAW-GLYPHS16
;               (DRAWABLE GCONTEXT X Y SEQUENCE START END TRANSLATE WIDTH)
;          (DECLARE (TYPE DRAWABLE DRAWABLE)
;                   (TYPE GCONTEXT GCONTEXT)
;                   (TYPE INT16 X Y)
;                   (TYPE ARRAY-INDEX START)
;                   (TYPE SEQUENCE SEQUENCE)
;                   (TYPE (OR NULL ARRAY-INDEX) END)
;                   (TYPE (OR NULL INT32) WIDTH))
;          (DECLARE (CLX-VALUES (OR NULL ARRAY-INDEX) (OR NULL INT32)))
;          (DECLARE (TYPE TRANSLATION-FUNCTION TRANSLATE)
;                   (DYNAMIC-EXTENT TRANSLATE))
;          (LET* ((SRC-START START)
;                 (SRC-END (OR END (LENGTH SEQUENCE)))
;                 (NEXT-START NIL)
;                 (LENGTH (INDEX- SRC-END SRC-START))
;                 (REQUEST-LENGTH (* LENGTH 3))
;                 (DISPLAY (GCONTEXT-DISPLAY GCONTEXT))
;                 (FONT (GCONTEXT-FONT GCONTEXT NIL))
;                 (BUFFER (DISPLAY-TBUF16 DISPLAY)))
;            (DECLARE (TYPE ARRAY-INDEX SRC-START SRC-END LENGTH)
;                     (TYPE (OR NULL ARRAY-INDEX) NEXT-START)
;                     (TYPE DISPLAY DISPLAY)
;                     (TYPE BUFFER-TEXT16 BUFFER))
;            (WITH-BUFFER-REQUEST (DISPLAY +X-POLYTEXT16+ :GC-FORCE GCONTEXT
;                                  :LENGTH REQUEST-LENGTH)
;              (DRAWABLE DRAWABLE)
;              (GCONTEXT GCONTEXT)
;              (INT16 X Y)
;              (PROGN
;               (WITH-BUFFER-FLUSH-INHIBITED (DISPLAY)
;                 (DO* ((BOFFSET (INDEX+ BUFFER-BOFFSET 16))
;                       (SRC-CHUNK 0)
;                       (DST-CHUNK 0)
;                       (OFFSET 0)
;                       (OVERALL-WIDTH 0)
;                       (STOP-P NIL))
;                      ((OR STOP-P (ZEROP LENGTH))
;                       (DO ((END (LROUND BOFFSET)))
;                           ((INDEX>= BOFFSET END))
;                         (SETF (AREF BUFFER-BBUF BOFFSET) 0)
;                         (INDEX-INCF BOFFSET))
;                       (LENGTH-PUT 2
;                                   (INDEX-ASH (INDEX- BOFFSET BUFFER-BOFFSET)
;                                              -2))
;                       (SETF (BUFFER-BOFFSET DISPLAY) BOFFSET)
;                       (UNLESS (ZEROP LENGTH) (SETQ NEXT-START SRC-START))
;                       (WHEN OVERALL-WIDTH (SETQ WIDTH OVERALL-WIDTH)))
;                   (DECLARE
;                    (TYPE ARRAY-INDEX BOFFSET SRC-CHUNK DST-CHUNK OFFSET)
;                    (TYPE (OR NULL INT32) OVERALL-WIDTH)
;                    (TYPE GENERALIZED-BOOLEAN STOP-P))
;                   (SETQ SRC-CHUNK (INDEX-MIN LENGTH *MAX-STRING-SIZE*))
;                   (MULTIPLE-VALUE-BIND (NEW-START NEW-FONT TRANSLATED-WIDTH)
;                       (FUNCALL TRANSLATE SEQUENCE SRC-START
;                                (INDEX+ SRC-START SRC-CHUNK) FONT BUFFER 0)
;                     (SETQ DST-CHUNK (INDEX- NEW-START SRC-START)
;                           LENGTH (INDEX- LENGTH DST-CHUNK)
;                           SRC-START NEW-START)
;                     (WRITE-SEQUENCE-CHAR2B DISPLAY (INDEX+ BOFFSET 2) BUFFER 0
;                                            DST-CHUNK)
;                     (IF TRANSLATED-WIDTH
;                         (WHEN OVERALL-WIDTH
;                           (INCF OVERALL-WIDTH TRANSLATED-WIDTH))
;                         (SETQ OVERALL-WIDTH NIL))
;                     (WHEN (INDEX-PLUSP DST-CHUNK)
;                       (SETF (AREF BUFFER-BBUF BOFFSET) DST-CHUNK)
;                       (SETF (AREF BUFFER-BBUF (INDEX+ BOFFSET 1)) OFFSET)
;                       (INDEX-INCF BOFFSET (INDEX+ DST-CHUNK DST-CHUNK 2)))
;                     (SETQ OFFSET 0)
;                     (COND
;                      ((NULL NEW-FONT)
;                       (UNLESS (INDEX= SRC-CHUNK DST-CHUNK) (SETQ STOP-P T)))
;                      ((INTEGERP NEW-FONT) (SETQ OFFSET NEW-FONT))
;                      ((TYPE? NEW-FONT 'FONT) (SETQ FONT NEW-FONT)
;                       (LET ((FONT-ID (FONT-ID FONT)) (BUFFER-BOFFSET BOFFSET))
;                         (DECLARE (TYPE RESOURCE-ID FONT-ID)
;                                  (TYPE ARRAY-INDEX BUFFER-BOFFSET))
;                         (LET ((LOCAL-STATE (GCONTEXT-LOCAL-STATE GCONTEXT))
;                               (SERVER-STATE (GCONTEXT-SERVER-STATE GCONTEXT)))
;                           (DECLARE
;                            (TYPE GCONTEXT-STATE LOCAL-STATE SERVER-STATE))
;                           (SETF (GCONTEXT-INTERNAL-FONT-OBJ SERVER-STATE) FONT
;                                 (GCONTEXT-INTERNAL-FONT SERVER-STATE) FONT-ID)
;                           (WITHOUT-INTERRUPTS
;                             (SETF (GCONTEXT-INTERNAL-FONT-OBJ LOCAL-STATE) FONT
;                                   (GCONTEXT-INTERNAL-FONT LOCAL-STATE)
;                                     FONT-ID)))
;                         (CARD8-PUT 0 255)
;                         (CARD8-PUT 1 (LDB (BYTE 8 24) FONT-ID))
;                         (CARD8-PUT 2 (LDB (BYTE 8 16) FONT-ID))
;                         (CARD8-PUT 3 (LDB (BYTE 8 8) FONT-ID))
;                         (CARD8-PUT 4 (LDB (BYTE 8 0) FONT-ID)))
;                       (INDEX-INCF BOFFSET 5))))))))
;            (VALUES NEXT-START WIDTH)))

;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-POLYTEXT16+ :GC-FORCE
;                                 XLIB:GCONTEXT :LENGTH XLIB::REQUEST-LENGTH)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       (XLIB:INT16 XLIB::X XLIB::Y)
;       (PROGN
;        (XLIB::WITH-BUFFER-FLUSH-INHIBITED (XLIB:DISPLAY)
;          (DO* (#
;                #
;                #
;                #
;                #
;                #)
;               (# # # # # #)
;            (DECLARE #
;                     #
;                     #)
;            (SETQ #)
;            (MULTIPLE-VALUE-BIND # # # # # # # #)))))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME SB-THREAD::WITH-RECURSIVE-LOCK-THUNK
;        :%DEBUG-NAME (FLET SB-THREAD::WITH-RECURSIVE-LOCK-THUNK :IN XLIB::DRAW-GLYPHS16)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS NIL {EBC00A9}>))
; 
; note: doing signed word to integer coercion (cost 20), for:
;       the second argument of CLOSURE-INIT

;     (INCF XLIB::OVERALL-WIDTH XLIB::TRANSLATED-WIDTH)
; --> LET* 
; ==>
;   (SETQ XLIB::OVERALL-WIDTH #:NEW1172)
; 
; note: doing signed word to integer coercion (cost 20) to OVERALL-WIDTH

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN DRAW-IMAGE-GLYPH
;     (LDB (BYTE 8 8) ELT)
; --> SB-KERNEL:%LDB LOGAND 
; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN DRAW-IMAGE-GLYPHS8
;     (DEFUN XLIB::DRAW-IMAGE-GLYPHS8
;            (XLIB:DRAWABLE XLIB:GCONTEXT XLIB::X XLIB::Y SEQUENCE XLIB::START
;             XLIB::END XLIB::TRANSLATE XLIB::WIDTH)
;       (DECLARE (TYPE XLIB:DRAWABLE XLIB:DRAWABLE)
;                (TYPE XLIB:GCONTEXT XLIB:GCONTEXT)
;                (TYPE XLIB:INT16 XLIB::X XLIB::Y)
;                (TYPE XLIB:ARRAY-INDEX XLIB::START)
;                (TYPE SEQUENCE SEQUENCE)
;                (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::END)
;                (TYPE (OR NULL XLIB:INT32) XLIB::WIDTH))
;       (DECLARE (TYPE (OR NULL XLIB:TRANSLATION-FUNCTION) XLIB::TRANSLATE)
;                (DYNAMIC-EXTENT XLIB::TRANSLATE))
;       (DECLARE
;        (XLIB::CLX-VALUES (OR NULL XLIB:ARRAY-INDEX) (OR NULL XLIB:INT32)))
;       (DO* ((XLIB:DISPLAY (XLIB:GCONTEXT-DISPLAY XLIB:GCONTEXT))
;             (LENGTH (XLIB::INDEX- XLIB::END XLIB::START))
;             (XLIB:FONT (XLIB:GCONTEXT-FONT XLIB:GCONTEXT NIL))
;             (XLIB::FONT-CHANGE NIL)
;             (XLIB::NEW-START)
;             (XLIB::TRANSLATED-WIDTH)
;             (XLIB::CHUNK))
;            (NIL)
;         (DECLARE (TYPE XLIB:DISPLAY XLIB:DISPLAY)
;                  (TYPE XLIB:ARRAY-INDEX LENGTH)
;                  (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::NEW-START XLIB::CHUNK))
;         (WHEN XLIB::FONT-CHANGE (SETF # XLIB:FONT))
;         (BLOCK XLIB::CHANGE-FONT
;           (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-IMAGETEXT8+ :GC-FORCE
;                                       XLIB:GCONTEXT :LENGTH LENGTH)
;             (XLIB:DRAWABLE XLIB:DRAWABLE)
;             (XLIB:GCONTEXT XLIB:GCONTEXT)
;             (XLIB:INT16 XLIB::X XLIB::Y)
;             (PROGN #))
;           (RETURN-FROM XLIB::DRAW-IMAGE-GLYPHS8 (VALUES # #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET 
; --> VALUES PROG1 LET 
; ==>
;   #:G1665
; 
; note: could not stack allocate TRANSLATE in:
;        (DEFUN DRAW-IMAGE-GLYPHS8
;               (DRAWABLE GCONTEXT X Y SEQUENCE START END TRANSLATE WIDTH)
;          (DECLARE (TYPE DRAWABLE DRAWABLE)
;                   (TYPE GCONTEXT GCONTEXT)
;                   (TYPE INT16 X Y)
;                   (TYPE ARRAY-INDEX START)
;                   (TYPE SEQUENCE SEQUENCE)
;                   (TYPE (OR NULL ARRAY-INDEX) END)
;                   (TYPE (OR NULL INT32) WIDTH))
;          (DECLARE (TYPE (OR NULL TRANSLATION-FUNCTION) TRANSLATE)
;                   (DYNAMIC-EXTENT TRANSLATE))
;          (DECLARE (CLX-VALUES (OR NULL ARRAY-INDEX) (OR NULL INT32)))
;          (DO* ((DISPLAY (GCONTEXT-DISPLAY GCONTEXT))
;                (LENGTH (INDEX- END START))
;                (FONT (GCONTEXT-FONT GCONTEXT NIL))
;                (FONT-CHANGE NIL)
;                (NEW-START)
;                (TRANSLATED-WIDTH)
;                (CHUNK))
;               (NIL)
;            (DECLARE (TYPE DISPLAY DISPLAY)
;                     (TYPE ARRAY-INDEX LENGTH)
;                     (TYPE (OR NULL ARRAY-INDEX) NEW-START CHUNK))
;            (WHEN FONT-CHANGE (SETF (GCONTEXT-FONT GCONTEXT) FONT))
;            (BLOCK CHANGE-FONT
;              (WITH-BUFFER-REQUEST (DISPLAY +X-IMAGETEXT8+ :GC-FORCE GCONTEXT
;                                    :LENGTH LENGTH)
;                (DRAWABLE DRAWABLE)
;                (GCONTEXT GCONTEXT)
;                (INT16 X Y)
;                (PROGN
;                 (WITH-BUFFER-FLUSH-INHIBITED (DISPLAY)
;                   (MULTIPLE-VALUE-SETQ (NEW-START FONT TRANSLATED-WIDTH)
;                     (FUNCALL (OR TRANSLATE #'TRANSLATE-DEFAULT) SEQUENCE START
;                              END FONT BUFFER-BBUF (INDEX+ BUFFER-BOFFSET 16)))
;                   (SETQ CHUNK (INDEX- NEW-START START))
;                   (WHEN (AND (INDEX-ZEROP CHUNK) (TYPE? FONT 'FONT))
;                     (SETQ FONT-CHANGE T)
;                     (RETURN-FROM CHANGE-FONT))
;                   (WHEN (INDEX-ZEROP CHUNK)
;                     (RETURN-FROM DRAW-IMAGE-GLYPHS8 NEW-START))
;                   (DATA-PUT 1 CHUNK)
;                   (LET ((BLEN (LROUND (INDEX+ 16 CHUNK))))
;                     (LENGTH-PUT 2 (INDEX-ASH BLEN -2))
;                     (SETF (BUFFER-BOFFSET DISPLAY)
;                             (INDEX+ BUFFER-BOFFSET BLEN))))))
;              (RETURN-FROM DRAW-IMAGE-GLYPHS8
;                (VALUES
;                 (IF (INDEX= CHUNK LENGTH)
;                     NIL
;                     NEW-START)
;                 (OR TRANSLATED-WIDTH WIDTH))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN DRAW-IMAGE-GLYPHS16
;     (DEFUN XLIB::DRAW-IMAGE-GLYPHS16
;            (XLIB:DRAWABLE XLIB:GCONTEXT XLIB::X XLIB::Y SEQUENCE XLIB::START
;             XLIB::END XLIB::TRANSLATE XLIB::WIDTH)
;       (DECLARE (TYPE XLIB:DRAWABLE XLIB:DRAWABLE)
;                (TYPE XLIB:GCONTEXT XLIB:GCONTEXT)
;                (TYPE XLIB:INT16 XLIB::X XLIB::Y)
;                (TYPE XLIB:ARRAY-INDEX XLIB::START)
;                (TYPE SEQUENCE SEQUENCE)
;                (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::END)
;                (TYPE (OR NULL XLIB:INT32) XLIB::WIDTH))
;       (DECLARE (TYPE (OR NULL XLIB:TRANSLATION-FUNCTION) XLIB::TRANSLATE)
;                (DYNAMIC-EXTENT XLIB::TRANSLATE))
;       (DECLARE
;        (XLIB::CLX-VALUES (OR NULL XLIB:ARRAY-INDEX) (OR NULL XLIB:INT32)))
;       (DO* ((XLIB:DISPLAY (XLIB:GCONTEXT-DISPLAY XLIB:GCONTEXT))
;             (LENGTH (XLIB::INDEX- XLIB::END XLIB::START))
;             (XLIB:FONT (XLIB:GCONTEXT-FONT XLIB:GCONTEXT NIL))
;             (XLIB::FONT-CHANGE NIL)
;             (XLIB::NEW-START)
;             (XLIB::TRANSLATED-WIDTH)
;             (XLIB::CHUNK)
;             (XLIB::BUFFER (XLIB::BUFFER-TBUF16 XLIB:DISPLAY)))
;            (NIL)
;         (DECLARE (TYPE XLIB:DISPLAY XLIB:DISPLAY)
;                  (TYPE XLIB:ARRAY-INDEX LENGTH)
;                  (TYPE (OR NULL XLIB:ARRAY-INDEX) XLIB::NEW-START XLIB::CHUNK)
;                  (TYPE XLIB::BUFFER-TEXT16 XLIB::BUFFER))
;         (WHEN XLIB::FONT-CHANGE (SETF # XLIB:FONT))
;         (BLOCK XLIB::CHANGE-FONT
;           (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::+X-IMAGETEXT16+
;                                       :GC-FORCE XLIB:GCONTEXT :LENGTH LENGTH)
;             (XLIB:DRAWABLE XLIB:DRAWABLE)
;             (XLIB:GCONTEXT XLIB:GCONTEXT)
;             (XLIB:INT16 XLIB::X XLIB::Y)
;             (PROGN #))
;           (RETURN-FROM XLIB::DRAW-IMAGE-GLYPHS16 (VALUES # #)))))
; --> PROGN EVAL-WHEN SB-IMPL::%DEFUN SB-C::%FUNCALL MULTIPLE-VALUE-BIND LET 
; --> VALUES PROG1 LET 
; ==>
;   #:G1805
; 
; note: could not stack allocate TRANSLATE in:
;        (DEFUN DRAW-IMAGE-GLYPHS16
;               (DRAWABLE GCONTEXT X Y SEQUENCE START END TRANSLATE WIDTH)
;          (DECLARE (TYPE DRAWABLE DRAWABLE)
;                   (TYPE GCONTEXT GCONTEXT)
;                   (TYPE INT16 X Y)
;                   (TYPE ARRAY-INDEX START)
;                   (TYPE SEQUENCE SEQUENCE)
;                   (TYPE (OR NULL ARRAY-INDEX) END)
;                   (TYPE (OR NULL INT32) WIDTH))
;          (DECLARE (TYPE (OR NULL TRANSLATION-FUNCTION) TRANSLATE)
;                   (DYNAMIC-EXTENT TRANSLATE))
;          (DECLARE (CLX-VALUES (OR NULL ARRAY-INDEX) (OR NULL INT32)))
;          (DO* ((DISPLAY (GCONTEXT-DISPLAY GCONTEXT))
;                (LENGTH (INDEX- END START))
;                (FONT (GCONTEXT-FONT GCONTEXT NIL))
;                (FONT-CHANGE NIL)
;                (NEW-START)
;                (TRANSLATED-WIDTH)
;                (CHUNK)
;                (BUFFER (BUFFER-TBUF16 DISPLAY)))
;               (NIL)
;            (DECLARE (TYPE DISPLAY DISPLAY)
;                     (TYPE ARRAY-INDEX LENGTH)
;                     (TYPE (OR NULL ARRAY-INDEX) NEW-START CHUNK)
;                     (TYPE BUFFER-TEXT16 BUFFER))
;            (WHEN FONT-CHANGE (SETF (GCONTEXT-FONT GCONTEXT) FONT))
;            (BLOCK CHANGE-FONT
;              (WITH-BUFFER-REQUEST (DISPLAY +X-IMAGETEXT16+ :GC-FORCE GCONTEXT
;                                    :LENGTH LENGTH)
;                (DRAWABLE DRAWABLE)
;                (GCONTEXT GCONTEXT)
;                (INT16 X Y)
;                (PROGN
;                 (WITH-BUFFER-FLUSH-INHIBITED (DISPLAY)
;                   (MULTIPLE-VALUE-SETQ (NEW-START FONT TRANSLATED-WIDTH)
;                     (FUNCALL (OR TRANSLATE #'TRANSLATE-DEFAULT) SEQUENCE START
;                              END FONT BUFFER 0))
;                   (SETQ CHUNK (INDEX- NEW-START START))
;                   (WHEN (AND (INDEX-ZEROP CHUNK) (TYPE? FONT 'FONT))
;                     (SETQ FONT-CHANGE T)
;                     (RETURN-FROM CHANGE-FONT))
;                   (WHEN (INDEX-ZEROP CHUNK)
;                     (RETURN-FROM DRAW-IMAGE-GLYPHS16 NEW-START))
;                   (WRITE-SEQUENCE-CHAR2B DISPLAY (INDEX+ BUFFER-BOFFSET 16)
;                                          BUFFER 0 CHUNK)
;                   (DATA-PUT 1 CHUNK)
;                   (LET ((BLEN (LROUND (INDEX+ 16 (INDEX-ASH CHUNK 1)))))
;                     (LENGTH-PUT 2 (INDEX-ASH BLEN -2))
;                     (SETF (BUFFER-BOFFSET DISPLAY)
;                             (INDEX+ BUFFER-BOFFSET BLEN))))))
;              (RETURN-FROM DRAW-IMAGE-GLYPHS16
;                (VALUES
;                 (IF (INDEX= CHUNK LENGTH)
;                     NIL
;                     NEW-START)
;                 (OR TRANSLATED-WIDTH WIDTH))))))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN CHANGE-KEYBOARD-MAPPING
;     (AREF XLIB::KEYSYMS XLIB::I XLIB::J)
; --> LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/text.lisp
; in: DEFUN KEYBOARD-MAPPING
;     (MAKE-ARRAY
;      `(,(XLIB::INDEX+ XLIB::START XLIB::KEYCODE-COUNT)
;        ,XLIB::KEYSYMS-PER-KEYCODE)
;      :ELEMENT-TYPE 'XLIB:KEYSYM :INITIAL-ELEMENT 0)
; --> LOCALLY MAKE-ARRAY MAKE-ARRAY LOCALLY 
; ==>
;   (MAKE-ARRAY SB-C::DIMS :ELEMENT-TYPE '(UNSIGNED-BYTE 32))
; 
; note: unable to
;   optimize
; because:
;   The dimension list is not constant; cannot open code array creation.

;     (1+ XLIB::I)
; ==>
;   (+ XLIB::I 1)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to
;   associate +/+ of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.
; 
; note: unable to
;   associate +/- of constants
; due to type uncertainty:
;   The first argument is a NUMBER, not a RATIONAL.

;     (SETF (AREF XLIB::RESULT XLIB::I XLIB::J) (XLIB::CARD29-GET (* XLIB::J 4)))
; --> LET* MULTIPLE-VALUE-BIND LET FUNCALL SB-C::%FUNCALL (SETF AREF) LET* 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-SET ARRAY SB-INT:INDEX SB-C::NEW-VALUE)
; 
; note: unable to
;   avoid runtime dispatch on array element type
; due to type uncertainty:
;   The first argument is a (ARRAY * (* *)), not a SIMPLE-ARRAY.

;     (1+ XLIB::I)
; ==>
;   (+ XLIB::I 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a NUMBER, not a FIXNUM.
;       The result is a (VALUES NUMBER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       etc.
; 
; compilation unit finished
;   printed 24 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/attributes.lisp
; in: DEFUN CHANGE-WINDOW-ATTRIBUTE
;     (ASH 1 NUMBER)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/attributes.lisp
; in: DEFUN CHANGE-DRAWABLE-GEOMETRY
;     (ASH 1 NUMBER)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.
; 
; compilation unit finished
;   printed 2 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/image.lisp
; in: DEFUN GET-IMAGE
;     (FIND XLIB::DEPTH (XLIB:DISPLAY-PIXMAP-FORMATS XLIB:DISPLAY) :KEY
;           #'XLIB:PIXMAP-FORMAT-DEPTH)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

;     (SETF (XLIB:IMAGE-BLUE-MASK XLIB:IMAGE)
;             (XLIB:VISUAL-INFO-BLUE-MASK XLIB:VISUAL-INFO))
; --> LET* MULTIPLE-VALUE-BIND LET LET 
; ==>
;   (SB-IMPL::%PUTF (XLIB:IMAGE-PLIST #:IMAGE2650) #:G2652 #:G2651)
; 
; note: doing unsigned word to integer coercion (cost 20)

;     (SETF (XLIB:IMAGE-GREEN-MASK XLIB:IMAGE)
;             (XLIB:VISUAL-INFO-GREEN-MASK XLIB:VISUAL-INFO))
; --> LET* MULTIPLE-VALUE-BIND LET LET 
; ==>
;   (SB-IMPL::%PUTF (XLIB:IMAGE-PLIST #:IMAGE2644) #:G2646 #:G2645)
; 
; note: doing unsigned word to integer coercion (cost 20)

;     (SETF (XLIB:IMAGE-RED-MASK XLIB:IMAGE)
;             (XLIB:VISUAL-INFO-RED-MASK XLIB:VISUAL-INFO))
; --> LET* MULTIPLE-VALUE-BIND LET LET 
; ==>
;   (SB-IMPL::%PUTF (XLIB:IMAGE-PLIST #:IMAGE2638) #:G2640 #:G2639)
; 
; note: doing unsigned word to integer coercion (cost 20)
; 
; compilation unit finished
;   printed 4 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/resource.lisp
; in: DEFUN DELETE-RESOURCE-INTERNAL
;     (SETQ XLIB::LOOSE-P NIL)
; 
; note: deleting unreachable code

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/resource.lisp
; in: DEFUN MAP-RESOURCE
;     (XLIB::MAP-RESOURCE-INTERNAL XLIB::RESOURCE FUNCTION XLIB::ARGS XLIB::NAME)
; ==>
;   FUNCTION
; 
; note: could not stack allocate FUNCTION in:
;        (MAP-RESOURCE-INTERNAL RESOURCE FUNCTION ARGS NAME)
; 
; note: could not stack allocate FUNCTION in:
;        (MAP-RESOURCE-INTERNAL RESOURCE FUNCTION ARGS NAME)
; 
; compilation unit finished
;   printed 3 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/shape.lisp
; in: DECLARE-EVENT :SHAPE-NOTIFY
;     (XLIB:DECLARE-EVENT :SHAPE-NOTIFY
;       ((XLIB::DATA (XLIB::MEMBER8 :BOUNDING :CLIP)) XLIB::KIND)
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (XLIB:INT16 XLIB::X)
;       (XLIB:INT16 XLIB::Y)
;       (XLIB:CARD16 XLIB::WIDTH)
;       (XLIB:CARD16 XLIB::HEIGHT)
;       ((OR NULL XLIB:CARD32) TIME)
;       (BOOLEAN XLIB::SHAPED-P))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G53
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :SHAPE-NOTIFY
;          ((DATA (MEMBER8 :BOUNDING :CLIP)) KIND)
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (INT16 X)
;          (INT16 Y)
;          (CARD16 WIDTH)
;          (CARD16 HEIGHT)
;          ((OR NULL CARD32) TIME)
;          (BOOLEAN SHAPED-P))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/shape.lisp
; in: DEFUN SHAPE-RECTANGLES
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY
;                                 (XLIB:EXTENSION-OPCODE XLIB:DISPLAY "SHAPE"))
;       (XLIB::DATA 1)
;       (XLIB:CARD8 (XLIB::ENCODE-SHAPE-OPERATION XLIB::OPERATION))
;       (XLIB:CARD8 (XLIB::ENCODE-SHAPE-KIND XLIB::KIND))
;       (XLIB:CARD8 (XLIB::ENCODE-SHAPE-RECTANGLE-ORDERING XLIB::ORDERING))
;       (XLIB:CARD8 0)
;       (XLIB:WINDOW XLIB:WINDOW)
;       (XLIB:INT16 XLIB::X-OFFSET)
;       (XLIB:INT16 XLIB::Y-OFFSET)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::RECTANGLES))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::RECTANGLES)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/shape.lisp
; in: DEFUN SHAPE-GET-RECTANGLES
;     (* 4 (XLIB::CARD32-GET 8))
; --> * 
; ==>
;   (ASH SB-C::X 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 17179869181) &OPTIONAL), not a (VALUES
;                                                                    FIXNUM &REST
;                                                                    T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 17179869181) &OPTIONAL), not a (VALUES
;                                                                    (UNSIGNED-BYTE
;                                                                     32)
;                                                                    &REST T).
;       etc.
; 
; compilation unit finished
;   printed 4 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DECLARE-EVENT :XFREE86-VIDMODE-NOTIFY
;     (XLIB:DECLARE-EVENT :XFREE86-VIDMODE-NOTIFY
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:WINDOW (XLIB:WINDOW XLIB::EVENT-WINDOW))
;       (XLIB:INT16 XLIB::STATE)
;       (XLIB:INT16 XLIB::KIND)
;       (BOOLEAN XLIB::FORCED-P)
;       ((OR NULL XLIB:CARD32) TIME))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G68
; 
; note: could not stack allocate HANDLER in:
;        (DECLARE-EVENT :XFREE86-VIDMODE-NOTIFY
;          (CARD16 SEQUENCE)
;          (WINDOW (WINDOW EVENT-WINDOW))
;          (INT16 STATE)
;          (INT16 KIND)
;          (BOOLEAN FORCED-P)
;          ((OR NULL CARD32) TIME))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-PERMISSIONS
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-MOD-MODE-LINE
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-MODE-LINE
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-ALL-MODE-LINES
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-ADD-MODE-LINE
;     (XLIB::SCREEN-POSITION XLIB::SCR XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-DELETE-MODE-LINE
;     (XLIB::SCREEN-POSITION XLIB::SCR XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-VALIDATE-MODE-LINE
;     (XLIB::SCREEN-POSITION XLIB::SCR XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-GAMMA
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-SET-GAMMA
;     (XLIB::SCREEN-POSITION XLIB::SCR XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-GAMMA-RAMP
;     (XLIB::SCREEN-POSITION XLIB::SCR XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-SET-GAMMA-RAMP
;     (XLIB::SCREEN-POSITION XLIB::SCR XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-GAMMA-RAMP-SIZE
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-LOCK-MODE-SWITCH
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-SWITCH-TO-MODE
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-SWITCH-MODE
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-SELECT-NEXT-MODE
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-SELECT-PREV-MODE
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB:DISPLAY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-MONITOR
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-VIEWPORT
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-SET-VIEWPORT
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xvidmode.lisp
; in: DEFUN XFREE86-VIDMODE-GET-DOTCLOCKS
;     (XLIB::SCREEN-POSITION XLIB:SCREEN XLIB::DPY)
; --> BLOCK LET POSITION NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.
; 
; compilation unit finished
;   printed 22 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DECLARE-EVENT :GLX-PBUFFER-CLOBBER
;     (XLIB:DECLARE-EVENT :GLX-PBUFFER-CLOBBER
;       (XLIB:CARD16 SEQUENCE)
;       (XLIB:CARD16 GLX::EVENT-TYPE)
;       (XLIB:CARD16 GLX::DRAW-TYPE)
;       (XLIB:RESOURCE-ID XLIB:DRAWABLE)
;       (XLIB:CARD32 GLX::BUFFER-MASK)
;       (XLIB:CARD16 GLX::AUX-BUFFER)
;       (XLIB:CARD16 GLX::X GLX::Y GLX::WIDTH GLX::HEIGHT COUNT))
; --> XLIB::WITHIN-DEFINITION PROGN DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN 
; --> SB-C::%FUNCALL 
; ==>
;   #:G231
; 
; note: could not stack allocate XLIB::HANDLER in:
;        (DECLARE-EVENT :GLX-PBUFFER-CLOBBER
;          (CARD16 SEQUENCE)
;          (CARD16 EVENT-TYPE)
;          (CARD16 DRAW-TYPE)
;          (RESOURCE-ID DRAWABLE)
;          (CARD32 BUFFER-MASK)
;          (CARD16 AUX-BUFFER)
;          (CARD16 X Y WIDTH HEIGHT COUNT))

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN QUERY-SERVER-STRING
;     (POSITION XLIB:SCREEN (XLIB:DISPLAY-ROOTS XLIB:DISPLAY) :TEST #'EQ)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN MAKE-CONTEXT
;     (XLIB::ALLOCATE-RESOURCE-ID XLIB:DISPLAY GLX::CTX 'GLX::CONTEXT)
; --> XLIB:WITH-DISPLAY XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK FUNCALL 
; --> SB-C::%FUNCALL THE 
; ==>
;   (SB-KERNEL:%COERCE-CALLABLE-TO-FUN (XLIB:DISPLAY-XID XLIB:DISPLAY))
; 
; note: unable to
;   optimize away possible call to FDEFINITION at runtime
; because:
;   not known to be a function

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN CREATE-CONTEXT
;     (POSITION XLIB:SCREEN (XLIB:DISPLAY-ROOTS XLIB:DISPLAY) :TEST #'EQ)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN QUERY-CONTEXT
;     (LOOP GLX::REPEAT GLX::NUM-ATTRIBUTES
;           GLX::FOR GLX::I FIXNUM GLX::UPFROM 32 GLX::BY 8
;           GLX::COLLECTING (CONS (XLIB::CARD32-GET GLX::I)
;                                 (XLIB::CARD32-GET (+ GLX::I 4))))
; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       etc.

; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY IF DECF LET* 
; ==>
;   (- #:LOOP-REPEAT-1038 #:G1049)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN GET-DRAWABLE-ATTRIBUTES
;     (LOOP GLX::REPEAT GLX::NUM-ATTRIBUTES
;           GLX::FOR GLX::I FIXNUM GLX::UPFROM 32 GLX::BY 8
;           GLX::COLLECTING (CONS (XLIB::CARD32-GET GLX::I)
;                                 (XLIB::CARD32-GET (+ GLX::I 4))))
; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY IF <= IF 
; ==>
;   (> SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       etc.

; --> BLOCK LET SB-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD LET* SB-LOOP::LOOP-BODY 
; --> TAGBODY IF DECF LET* 
; ==>
;   (- #:LOOP-REPEAT-1139 #:G1150)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER 1), not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN MAKE-CURRENT
;     (XLIB::WITH-BUFFER-REQUEST-AND-REPLY (XLIB:DISPLAY
;                                           (XLIB:EXTENSION-OPCODE XLIB:DISPLAY
;                                                                  "GLX")
;                                           NIL)
;         ((XLIB::DATA GLX::+MAKE-CURRENT+)
;          (XLIB:RESOURCE-ID (XLIB:DRAWABLE-ID XLIB:DRAWABLE))
;          (XLIB:RESOURCE-ID (GLX::CONTEXT-ID GLX::CTX)) (XLIB:CARD32 GLX::OLD-TAG))
;       (LET ((GLX::NEW-TAG (XLIB::CARD32-GET 8)))
;         (SETF (GLX::CONTEXT-TAG GLX::CTX) GLX::NEW-TAG
;               (GLX::CONTEXT-DRAWABLE GLX::CTX) XLIB:DRAWABLE
;               (GLX::CONTEXT-DISPLAY GLX::CTX) XLIB:DISPLAY
;               GLX::*CURRENT-CONTEXT* GLX::CTX)))
; --> LET UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> BLOCK SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN XLIB::WITH-BUFFER MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> SB-C::%%ALLOCATE-CLOSURES 
; ==>
;   (SB-C::%ALLOCATE-CLOSURES
;    '(#<SB-C::CLAMBDA
;        :%SOURCE-NAME SB-THREAD::WITH-RECURSIVE-LOCK-THUNK
;        :%DEBUG-NAME (FLET SB-THREAD::WITH-RECURSIVE-LOCK-THUNK :IN GLX:MAKE-CURRENT)
;        :KIND NIL
;        :TYPE #<SB-KERNEL:FUN-TYPE #>
;        :WHERE-FROM :DEFINED
;        :VARS NIL {D928489}>))
; 
; note: doing unsigned word to integer coercion (cost 20) from OLD-TAG, for:
;       the second argument of CLOSURE-INIT

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN GET-VISUAL-CONFIGS
;     (LOOP GLX::REPEAT (/ (- GLX::NUM-PROPERTIES GLX::NUM-ORDERED) 2)
;           GLX::COLLECTING (CONS (XLIB::CARD32-GET (INCF GLX::INDEX 4))
;                                 (XLIB::CARD32-GET (INCF GLX::INDEX 4))))
; --> BLOCK LET CEILING CEILING SB-KERNEL:%CEILING BLOCK MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL TRUNCATE LET VALUES 
; ==>
;   (- SB-C::X SB-C::RES)
; 
; note: forced to do GENERIC-- (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (RATIONAL -536870907/2 536870911/2), not a FIXNUM.
;       The result is a (VALUES (RATIONAL (-1) (1)) &OPTIONAL), not a (VALUES
;                                                                      FIXNUM
;                                                                      &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The first argument is a (RATIONAL -536870907/2 536870911/2), not a (SIGNED-BYTE
;                                                                           32).
;       The result is a (VALUES (RATIONAL (-1) (1)) &OPTIONAL), not a (VALUES
;                                                                      (SIGNED-BYTE
;                                                                       32)
;                                                                      &REST T).
;       etc.

; --> BLOCK LET CEILING CEILING SB-KERNEL:%CEILING BLOCK MULTIPLE-VALUE-BIND 
; --> MULTIPLE-VALUE-CALL FUNCTION IF AND IF AND THE IF PLUSP 
; ==>
;   (> NUMBER 0)
; 
; note: forced to do GENERIC-> (cost 10)
;       unable to do inline fixnum comparison (cost 3) because:
;       The first argument is a (RATIONAL -536870907/2 536870911/2), not a FIXNUM.
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (RATIONAL -536870907/2 536870911/2), not a FIXNUM.
;       etc.

;     (POSITION XLIB:SCREEN (XLIB:DISPLAY-ROOTS XLIB:DISPLAY) :TEST #'EQ)
; --> NTH-VALUE MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> SB-KERNEL:%FIND-POSITION SB-KERNEL:%FIND-POSITION-IF LET FLET IF DO BLOCK 
; --> LET TAGBODY PSETQ PSETF LET* MULTIPLE-VALUE-BIND LET LET* 
; --> MULTIPLE-VALUE-BIND LET LET* MULTIPLE-VALUE-BIND LET 
; ==>
;   (+ SB-INT:INDEX 1)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES (INTEGER 1) &OPTIONAL), not a (VALUES FIXNUM
;                                                                     &REST T).
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN RENDER
;     (XLIB::ASET-CARD32 (GLX::CONTEXT-TAG GLX::CTX) GLX::RBUF 4)
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN SWAP-BUFFERS
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY
;                                 (XLIB:EXTENSION-OPCODE XLIB:DISPLAY "GLX"))
;       (XLIB::DATA GLX::+SWAP-BUFFERS+)
;       (XLIB:CARD32 (GLX::CONTEXT-TAG GLX::CTX))
;       (XLIB:RESOURCE-ID (XLIB:DRAWABLE-ID (GLX::CONTEXT-DRAWABLE GLX::CTX))))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT LET XLIB::CARD32-PUT XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN WAIT-GL
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY
;                                 (XLIB:EXTENSION-OPCODE XLIB:DISPLAY "GLX"))
;       (XLIB::DATA GLX::+WAIT-GL+)
;       (XLIB:CARD32 (GLX::CONTEXT-TAG GLX::CTX)))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT LET XLIB::CARD32-PUT XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/glx.lisp
; in: DEFUN WAIT-X
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY
;                                 (XLIB:EXTENSION-OPCODE XLIB:DISPLAY "GLX"))
;       (XLIB::DATA GLX::+WAIT-X+)
;       (XLIB:CARD32 (GLX::CONTEXT-TAG GLX::CTX)))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT LET XLIB::CARD32-PUT XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)
; 
; compilation unit finished
;   printed 16 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN ASET-FLOAT32
;     (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN ASET-FLOAT64
;     (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

;     (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER INT8
;     (GL::DEFINE-SEQUENCE-SETTER XLIB:INT8)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY XLIB::ASET-INT8 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER INT16
;     (GL::DEFINE-SEQUENCE-SETTER XLIB:INT16)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY XLIB::ASET-INT16 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER INT32
;     (GL::DEFINE-SEQUENCE-SETTER XLIB:INT32)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY XLIB::ASET-INT32 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER BOOL
;     (GL::DEFINE-SEQUENCE-SETTER GL::BOOL)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY XLIB::ASET-CARD8 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER CARD8
;     (GL::DEFINE-SEQUENCE-SETTER XLIB:CARD8)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY XLIB::ASET-CARD8 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER CARD16
;     (GL::DEFINE-SEQUENCE-SETTER XLIB:CARD16)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY XLIB::ASET-CARD16 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER CARD32
;     (GL::DEFINE-SEQUENCE-SETTER XLIB:CARD32)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY XLIB::ASET-CARD32 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER FLOAT32
;     (GL::DEFINE-SEQUENCE-SETTER GL::FLOAT32)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY GL::ASET-FLOAT32 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF PROGN 
; --> LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> COND IF PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY GL::ASET-FLOAT32 BLOCK 
; --> LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY GL::ASET-FLOAT32 BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-SEQUENCE-SETTER FLOAT64
;     (GL::DEFINE-SEQUENCE-SETTER GL::FLOAT64)
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY GL::ASET-FLOAT64 AREF 
; ==>
;   (SB-KERNEL:HAIRY-DATA-VECTOR-REF ARRAY SB-INT:INDEX)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a (SIMPLE-ARRAY * (*)), not a SIMPLE-STRING.
; 
; note: unable to
;   avoid runtime dispatch on array element type
; because:
;   Upgraded element type of array is not known at compile time.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK ASSERT TAGBODY LET 
; --> SB-KERNEL:ASSERT-ERROR 
; ==>
;   (LENGTH GL::SEQ)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF PROGN 
; --> LET DOLIST BLOCK LET TAGBODY UNLESS IF PROGN LET TAGBODY GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> COND IF PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY GL::ASET-FLOAT64 BLOCK 
; --> LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK TYPECASE LET COND IF COND IF 
; --> PROGN DOTIMES DO BLOCK LET TAGBODY TAGBODY GL::ASET-FLOAT64 BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN GET-STRING
;     (XLIB::WITH-BUFFER-REQUEST-AND-REPLY (XLIB:DISPLAY
;                                           (XLIB:EXTENSION-OPCODE XLIB:DISPLAY
;                                                                  "GLX")
;                                           NIL)
;         ((XLIB::DATA GL::+GET-STRING+) (XLIB:CARD32 (GLX::CONTEXT-TAG GL::CTX))
;          (XLIB:CARD32 GL::NAME))
;       (LET* ((LENGTH (XLIB::CARD32-GET 12))
;              (GL::BYTES
;               (XLIB::SEQUENCE-GET :FORMAT XLIB:CARD8 :RESULT-TYPE '# :INDEX 32
;                                   :LENGTH LENGTH)))
;         (DECLARE (TYPE (SIMPLE-ARRAY XLIB:CARD8 #) GL::BYTES)
;                  (TYPE FIXNUM LENGTH))
;         (MAP-INTO (MAKE-STRING (1- LENGTH)) #'CODE-CHAR GL::BYTES)))
; --> LET UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> BLOCK SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN XLIB::WITH-BUFFER MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK XLIB::WITHOUT-ABORTS PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CHECK-PUT LET XLIB::CARD32-PUT 
; --> XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND ACCUM
;     (GL::DEFINE-RENDERING-COMMAND GL:ACCUM 137 (GL::OP XLIB:CARD32)
;                                   (GL::VALUE GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND ALPHA-FUNC
;     (GL::DEFINE-RENDERING-COMMAND GL:ALPHA-FUNC 159 (GL::FUNC XLIB:CARD32)
;                                   (GL::REF GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND BLEND-COLOR
;     (GL::DEFINE-RENDERING-COMMAND GL:BLEND-COLOR 4096 (GL::RED GL::FLOAT32)
;                                   (GL::GREEN GL::FLOAT32) (GL::BLUE GL::FLOAT32)
;                                   (GL::ALPHA GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND CLEAR-ACCUM
;     (GL::DEFINE-RENDERING-COMMAND GL:CLEAR-ACCUM 128 (GL::RED GL::FLOAT32)
;                                   (GL::GREEN GL::FLOAT32) (GL::BLUE GL::FLOAT32)
;                                   (GL::ALPHA GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND CLEAR-COLOR
;     (GL::DEFINE-RENDERING-COMMAND GL:CLEAR-COLOR 130 (GL::RED GL::FLOAT32)
;                                   (GL::GREEN GL::FLOAT32) (GL::BLUE GL::FLOAT32)
;                                   (GL::ALPHA GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND CLEAR-DEPTH
;     (GL::DEFINE-RENDERING-COMMAND GL:CLEAR-DEPTH 132 (GL::DEPTH GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND CLEAR-INDEX
;     (GL::DEFINE-RENDERING-COMMAND GL:CLEAR-INDEX 129 (GL::C GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND CLIP-PLANE
;     (GL::DEFINE-RENDERING-COMMAND GL:CLIP-PLANE 77 (GL::EQUOTION-0 GL::FLOAT64)
;                                   (GL::EQUOTION-1 GL::FLOAT64)
;                                   (GL::EQUOTION-2 GL::FLOAT64)
;                                   (GL::EQUOTION-3 GL::FLOAT64)
;                                   (GL::PLANE XLIB:CARD32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND COLOR-3D
;     (GL::DEFINE-RENDERING-COMMAND GL:COLOR-3D 7 ((GL::R GL::G GL::B) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND COLOR-3F
;     (GL::DEFINE-RENDERING-COMMAND GL:COLOR-3F 8 ((GL::R GL::G GL::B) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND COLOR-4D
;     (GL::DEFINE-RENDERING-COMMAND GL:COLOR-4D 15
;                                   ((GL::R GL::G GL::B GL::A) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND COLOR-4F
;     (GL::DEFINE-RENDERING-COMMAND GL:COLOR-4F 16
;                                   ((GL::R GL::G GL::B GL::A) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND CONVOLUTION-PARAMETER-F
;     (GL::DEFINE-RENDERING-COMMAND GL:CONVOLUTION-PARAMETER-F 4103
;                                   (GL::TARGET XLIB:CARD32)
;                                   (GL::PNAME XLIB:CARD32)
;                                   (GL::PARAMS GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND DEPTH-RANGE
;     (GL::DEFINE-RENDERING-COMMAND GL:DEPTH-RANGE 174 (GL::Z-NEAR GL::FLOAT64)
;                                   (GL::Z-FAR GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND EVAL-COORD-1D
;     (GL::DEFINE-RENDERING-COMMAND GL:EVAL-COORD-1D 151 (GL::U-0 GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND EVAL-COORD-1F
;     (GL::DEFINE-RENDERING-COMMAND GL:EVAL-COORD-1F 152 (GL::U-0 GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND EVAL-COORD-2D
;     (GL::DEFINE-RENDERING-COMMAND GL:EVAL-COORD-2D 153
;                                   ((GL::U-0 GL::U-1) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND EVAL-COORD-2F
;     (GL::DEFINE-RENDERING-COMMAND GL:EVAL-COORD-2F 154
;                                   ((GL::U-0 GL::U-1) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND FOG-F
;     (GL::DEFINE-RENDERING-COMMAND GL:FOG-F 80 (GL::PNAME XLIB:CARD32)
;                                   (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND FRUSTUM
;     (GL::DEFINE-RENDERING-COMMAND GL:FRUSTUM 175 (GL::LEFT GL::FLOAT64)
;                                   (GL::RIGHT GL::FLOAT64)
;                                   (GL::BOTTOM GL::FLOAT64) (GL::TOP GL::FLOAT64)
;                                   (GL::Z-NEAR GL::FLOAT64)
;                                   (GL::Z-FAR GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND INDEX-D
;     (GL::DEFINE-RENDERING-COMMAND GL:INDEX-D 24 (GL::C-0 GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND INDEX-F
;     (GL::DEFINE-RENDERING-COMMAND GL:INDEX-F 25 (GL::C-0 GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND LIGHT-MODEL-F
;     (GL::DEFINE-RENDERING-COMMAND GL:LIGHT-MODEL-F 90 (GL::PNAME XLIB:CARD32)
;                                   (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND LIGHT-F
;     (GL::DEFINE-RENDERING-COMMAND GL:LIGHT-F 86 (GL::LIGHT XLIB:CARD32)
;                                   (GL::PNAME XLIB:CARD32) (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND LINE-WIDTH
;     (GL::DEFINE-RENDERING-COMMAND GL:LINE-WIDTH 95 (GL::WIDTH GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MAP-GRID-1D
;     (GL::DEFINE-RENDERING-COMMAND GL:MAP-GRID-1D 147 (GL::U1 GL::FLOAT64)
;                                   (GL::U2 GL::FLOAT64) (GL::UN XLIB:INT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MAP-GRID-1F
;     (GL::DEFINE-RENDERING-COMMAND GL:MAP-GRID-1F 148 (GL::UN XLIB:INT32)
;                                   (GL::U1 GL::FLOAT32) (GL::U2 GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MAP-GRID-2D
;     (GL::DEFINE-RENDERING-COMMAND GL:MAP-GRID-2D 149 (GL::U1 GL::FLOAT64)
;                                   (GL::U2 GL::FLOAT64) (GL::V1 GL::FLOAT64)
;                                   (GL::V2 GL::FLOAT64) (GL::UN XLIB:INT32)
;                                   (GL::VN XLIB:INT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MAP-GRID-2F
;     (GL::DEFINE-RENDERING-COMMAND GL:MAP-GRID-2F 150 (GL::UN XLIB:INT32)
;                                   (GL::U1 GL::FLOAT32) (GL::U2 GL::FLOAT32)
;                                   (GL::VN XLIB:INT32) (GL::V1 GL::FLOAT32)
;                                   (GL::V2 GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MATERIAL-F
;     (GL::DEFINE-RENDERING-COMMAND GL:MATERIAL-F 96 (GL::FACE XLIB:CARD32)
;                                   (GL::PNAME XLIB:CARD32) (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-1D-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-1D-ARB 198
;                                   (GL::V-0 GL::FLOAT64) (GL::TARGET XLIB:CARD32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-1F-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-1F-ARB 199
;                                   (GL::TARGET XLIB:CARD32) (GL::V-0 GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-2D-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-2D-ARB 202
;                                   ((GL::V-0 GL::V-1) GL::FLOAT64)
;                                   (GL::TARGET XLIB:CARD32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-2F-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-2F-ARB 203
;                                   (GL::TARGET XLIB:CARD32)
;                                   ((GL::V-0 GL::V-1) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-3D-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-3D-ARB 206
;                                   ((GL::V-0 GL::V-1 GL::V-2) GL::FLOAT64)
;                                   (GL::TARGET XLIB:CARD32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-3F-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-3F-ARB 207
;                                   (GL::TARGET XLIB:CARD32)
;                                   ((GL::V-0 GL::V-1 GL::V-2) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-4D-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-4D-ARB 210
;                                   ((GL::V-0 GL::V-1 GL::V-2 GL::V-3) GL::FLOAT64)
;                                   (GL::TARGET XLIB:CARD32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND MULTI-TEX-COORD-4F-ARB
;     (GL::DEFINE-RENDERING-COMMAND GL:MULTI-TEX-COORD-4F-ARB 211
;                                   (GL::TARGET XLIB:CARD32)
;                                   ((GL::V-0 GL::V-1 GL::V-2 GL::V-3) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND NORMAL-3D
;     (GL::DEFINE-RENDERING-COMMAND GL:NORMAL-3D 29
;                                   ((GL::V-0 GL::V-1 GL::V-2) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND NORMAL-3F
;     (GL::DEFINE-RENDERING-COMMAND GL:NORMAL-3F 30
;                                   ((GL::V-0 GL::V-1 GL::V-2) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND ORTHO
;     (GL::DEFINE-RENDERING-COMMAND GL:ORTHO 182 (GL::LEFT GL::FLOAT64)
;                                   (GL::RIGHT GL::FLOAT64)
;                                   (GL::BOTTOM GL::FLOAT64) (GL::TOP GL::FLOAT64)
;                                   (GL::Z-NEAR GL::FLOAT64)
;                                   (GL::Z-FAR GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND PASS-THROUGH
;     (GL::DEFINE-RENDERING-COMMAND GL:PASS-THROUGH 123 (GL::TOKEN GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND PIXEL-TRANSFER-F
;     (GL::DEFINE-RENDERING-COMMAND GL:PIXEL-TRANSFER-F 166 (GL::PNAME XLIB:CARD32)
;                                   (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND PIXEL-ZOOM
;     (GL::DEFINE-RENDERING-COMMAND GL:PIXEL-ZOOM 165 (GL::XFACTOR GL::FLOAT32)
;                                   (GL::YFACTOR GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND POINT-SIZE
;     (GL::DEFINE-RENDERING-COMMAND GL:POINT-SIZE 100 (GL::SIZE GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND POLYGON-OFFSET
;     (GL::DEFINE-RENDERING-COMMAND GL:POLYGON-OFFSET 192 (GL::FACTOR GL::FLOAT32)
;                                   (GL::UNITS GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND PRIORITIZE-TEXTURES
;     (GL::DEFINE-RENDERING-COMMAND GL::PRIORITIZE-TEXTURES 4118 (GL::N XLIB:INT32)
;                                   (GL::TEXTURES (LIST XLIB:CARD32 GL::N))
;                                   (GL::PRIORITIES (LIST GL::FLOAT32 GL::N)))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + * CEILING + + + * * 
; ==>
;   (ASH SB-C::X 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (SIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (INTEGER -8589934592 8589934588) &OPTIONAL), not a (VALUES
;                                                                                   FIXNUM
;                                                                                   &REST
;                                                                                   T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a (SIGNED-BYTE 32), not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES (INTEGER -8589934592 8589934588) &OPTIONAL), not a (VALUES
;                                                                                   (UNSIGNED-BYTE
;                                                                                    32)
;                                                                                   &REST
;                                                                                   T).
;       etc.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + * CEILING + + + 
; ==>
;   (+
;    (TRULY-THE #<SB-KERNEL:NUMERIC-TYPE (INTEGER -8589934592 8589934588)>
;               SB-C::Y)
;    4)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -8589934592 8589934588), not a FIXNUM.
;       The result is a (VALUES (INTEGER -8589934588 8589934592) &OPTIONAL), not a (VALUES
;                                                                                   FIXNUM
;                                                                                   &REST
;                                                                                   T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -8589934592 8589934588), not a FIXNUM.
;       The result is a (VALUES (INTEGER -8589934588 8589934592) &OPTIONAL), not a (VALUES
;                                                                                   FIXNUM
;                                                                                   &REST
;                                                                                   T).
;       etc.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + * CEILING + + * * 
; ==>
;   (ASH SB-C::X 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (SIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (INTEGER -8589934592 8589934588) &OPTIONAL), not a (VALUES
;                                                                                   FIXNUM
;                                                                                   &REST
;                                                                                   T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a (SIGNED-BYTE 32), not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES (INTEGER -8589934592 8589934588) &OPTIONAL), not a (VALUES
;                                                                                   (UNSIGNED-BYTE
;                                                                                    32)
;                                                                                   &REST
;                                                                                   T).
;       etc.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + * CEILING + 
; ==>
;   (+ (+ 4 (* 4 GL::N)) (* 4 GL::N))
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -8589934588 8589934592), not a FIXNUM.
;       The second argument is a (INTEGER -8589934592 8589934588), not a FIXNUM.
;       The result is a (VALUES (INTEGER -17179869180 17179869180) &OPTIONAL), not a (VALUES
;                                                                                     FIXNUM
;                                                                                     &REST
;                                                                                     T).
;       unable to do inline (signed-byte 32) arithmetic (cost 5) because:
;       The first argument is a (INTEGER -8589934588 8589934592), not a (SIGNED-BYTE
;                                                                        32).
;       The second argument is a (INTEGER -8589934592 8589934588), not a (SIGNED-BYTE
;                                                                         32).
;       The result is a (VALUES (INTEGER -17179869180 17179869180) &OPTIONAL), not a (VALUES
;                                                                                     (SIGNED-BYTE
;                                                                                      32)
;                                                                                     &REST
;                                                                                     T).
;       etc.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + * CEILING LET 
; ==>
;   (+ SB-C::X 3)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -17179869180 17179869180), not a FIXNUM.
;       The result is a (VALUES (INTEGER -17179869177 17179869183) &OPTIONAL), not a (VALUES
;                                                                                     FIXNUM
;                                                                                     &REST
;                                                                                     T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -17179869180 17179869180), not a FIXNUM.
;       The result is a (VALUES (INTEGER -17179869177 17179869183) &OPTIONAL), not a (VALUES
;                                                                                     FIXNUM
;                                                                                     &REST
;                                                                                     T).
;       etc.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + * CEILING LET VALUES 
; ==>
;   (ASH SB-C::X -2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (INTEGER -17179869177 17179869183), not a FIXNUM.
;       The result is a (VALUES (INTEGER -4294967295 4294967295) &OPTIONAL), not a (VALUES
;                                                                                   FIXNUM
;                                                                                   &REST
;                                                                                   T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a (INTEGER -17179869177 17179869183), not a (UNSIGNED-BYTE
;                                                                          32).
;       The result is a (VALUES (INTEGER -4294967295 4294967295) &OPTIONAL), not a (VALUES
;                                                                                   (UNSIGNED-BYTE
;                                                                                    32)
;                                                                                   &REST
;                                                                                   T).
;       etc.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + * * 
; ==>
;   (ASH SB-C::X 2)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (INTEGER -4294967295 4294967295), not a FIXNUM.
;       The result is a (VALUES (INTEGER -17179869180 17179869180) &OPTIONAL), not a (VALUES
;                                                                                     FIXNUM
;                                                                                     &REST
;                                                                                     T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a (INTEGER -4294967295 4294967295), not a (UNSIGNED-BYTE
;                                                                        32).
;       The result is a (VALUES (INTEGER -17179869180 17179869180) &OPTIONAL), not a (VALUES
;                                                                                     (UNSIGNED-BYTE
;                                                                                      32)
;                                                                                     &REST
;                                                                                     T).
;       etc.

; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* + 
; ==>
;   (+
;    (TRULY-THE #<SB-KERNEL:NUMERIC-TYPE (INTEGER -17179869180 17179869180)>
;               SB-C::Y)
;    4)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (INTEGER -17179869180 17179869180), not a FIXNUM.
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (INTEGER -17179869180 17179869180), not a FIXNUM.
;       etc.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RASTER-POS-2D
;     (GL::DEFINE-RENDERING-COMMAND GL:RASTER-POS-2D 33
;                                   ((GL::V-0 GL::V-1) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RASTER-POS-2F
;     (GL::DEFINE-RENDERING-COMMAND GL:RASTER-POS-2F 34
;                                   ((GL::V-0 GL::V-1) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RASTER-POS-3D
;     (GL::DEFINE-RENDERING-COMMAND GL:RASTER-POS-3D 37
;                                   ((GL::V-0 GL::V-1 GL::V-2) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RASTER-POS-3F
;     (GL::DEFINE-RENDERING-COMMAND GL:RASTER-POS-3F 38
;                                   ((GL::V-0 GL::V-1 GL::V-2) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RASTER-POS-4D
;     (GL::DEFINE-RENDERING-COMMAND GL:RASTER-POS-4D 41
;                                   ((GL::V-0 GL::V-1 GL::V-2 GL::V-3) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RASTER-POS-4F
;     (GL::DEFINE-RENDERING-COMMAND GL:RASTER-POS-4F 42
;                                   ((GL::V-0 GL::V-1 GL::V-2 GL::V-3) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RECT-D
;     (GL::DEFINE-RENDERING-COMMAND GL:RECT-D 45
;                                   ((GL::V1-0 GL::V1-1 GL::V2-0 GL::V2-1)
;                                    GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND RECT-F
;     (GL::DEFINE-RENDERING-COMMAND GL:RECT-F 46
;                                   ((GL::V1-0 GL::V1-1 GL::V2-0 GL::V2-1)
;                                    GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND ROTATE-D
;     (GL::DEFINE-RENDERING-COMMAND GL:ROTATE-D 185
;                                   ((XLIB:ANGLE GL::X GL::Y GL::Z) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND ROTATE-F
;     (GL::DEFINE-RENDERING-COMMAND GL:ROTATE-F 186
;                                   ((XLIB:ANGLE GL::X GL::Y GL::Z) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND SCALE-D
;     (GL::DEFINE-RENDERING-COMMAND GL:SCALE-D 187
;                                   ((GL::X GL::Y GL::Z) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND SCALE-F
;     (GL::DEFINE-RENDERING-COMMAND GL:SCALE-F 188
;                                   ((GL::X GL::Y GL::Z) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND TEX-ENV-F
;     (GL::DEFINE-RENDERING-COMMAND GL:TEX-ENV-F 111 (GL::TARGET XLIB:CARD32)
;                                   (GL::PNAME XLIB:CARD32) (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND TEX-GEN-D
;     (GL::DEFINE-RENDERING-COMMAND GL:TEX-GEN-D 115 (GL::PARAM GL::FLOAT64)
;                                   (GL::COORD XLIB:CARD32) (GL::PNAME XLIB:CARD32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND TEX-GEN-F
;     (GL::DEFINE-RENDERING-COMMAND GL:TEX-GEN-F 117 (GL::COORD XLIB:CARD32)
;                                   (GL::PNAME XLIB:CARD32) (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND TEX-PARAMETER-F
;     (GL::DEFINE-RENDERING-COMMAND GL:TEX-PARAMETER-F 105 (GL::TARGET XLIB:CARD32)
;                                   (GL::PNAME XLIB:CARD32) (GL::PARAM GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND TRANSLATE-D
;     (GL::DEFINE-RENDERING-COMMAND GL:TRANSLATE-D 189
;                                   ((GL::X GL::Y GL::Z) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND TRANSLATE-F
;     (GL::DEFINE-RENDERING-COMMAND GL:TRANSLATE-F 190
;                                   ((GL::X GL::Y GL::Z) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND VERTEX-2D
;     (GL::DEFINE-RENDERING-COMMAND GL:VERTEX-2D 65 ((GL::X GL::Y) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND VERTEX-2F
;     (GL::DEFINE-RENDERING-COMMAND GL:VERTEX-2F 66 ((GL::X GL::Y) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND VERTEX-3D
;     (GL::DEFINE-RENDERING-COMMAND GL:VERTEX-3D 69
;                                   ((GL::X GL::Y GL::Z) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND VERTEX-3F
;     (GL::DEFINE-RENDERING-COMMAND GL:VERTEX-3F 70
;                                   ((GL::X GL::Y GL::Z) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND VERTEX-4D
;     (GL::DEFINE-RENDERING-COMMAND GL:VERTEX-4D 73
;                                   ((GL::X GL::Y GL::Z GL::W) GL::FLOAT64))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT64 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::LOW ARRAY GL::INDEX)
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (XLIB::ASET-CARD32 GL::HIGH ARRAY (THE XLIB:ARRAY-INDEX (+ GL::INDEX 4)))
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFINE-RENDERING-COMMAND VERTEX-4F
;     (GL::DEFINE-RENDERING-COMMAND GL:VERTEX-4F 74
;                                   ((GL::X GL::Y GL::Z GL::W) GL::FLOAT32))
; --> DEFUN PROGN EVAL-WHEN SB-IMPL::%DEFUN BLOCK LET* PROGN GL::ASET-FLOAT32 
; --> BLOCK LET 
; ==>
;   (XLIB::ASET-CARD32 GL::BITS ARRAY GL::INDEX)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN NEW-LIST
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY
;                                 (XLIB:EXTENSION-OPCODE XLIB:DISPLAY "GLX"))
;       (XLIB::DATA GL::+NEW-LIST+)
;       (XLIB:CARD32 (GLX::CONTEXT-TAG GL::CTX))
;       (XLIB:CARD32 LIST)
;       (XLIB:CARD32 GL::MODE))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT LET XLIB::CARD32-PUT XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN GEN-LISTS
;     (XLIB::WITH-BUFFER-REQUEST-AND-REPLY (XLIB:DISPLAY
;                                           (XLIB:EXTENSION-OPCODE XLIB:DISPLAY
;                                                                  "GLX")
;                                           NIL)
;         ((XLIB::DATA GL::+GEN-LISTS+) (XLIB:CARD32 (GLX::CONTEXT-TAG GL::CTX))
;          (INTEGER GL::RANGE))
;       (XLIB::CARD32-GET 8))
; --> LET UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> BLOCK SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN XLIB::WITH-BUFFER MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK XLIB::WITHOUT-ABORTS PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CHECK-PUT LET XLIB::CARD32-PUT 
; --> XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN END-LIST
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY
;                                 (XLIB:EXTENSION-OPCODE XLIB:DISPLAY "GLX"))
;       (XLIB::DATA GL::+END-LIST+)
;       (XLIB:CARD32 (GLX::CONTEXT-TAG GL::CTX)))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT LET XLIB::CARD32-PUT XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN ENABLE
;     (XLIB::WITH-BUFFER-REQUEST-AND-REPLY (XLIB:DISPLAY
;                                           (XLIB:EXTENSION-OPCODE XLIB:DISPLAY
;                                                                  "GLX")
;                                           NIL)
;         ((XLIB::DATA GL::+ENABLE+) (XLIB:CARD32 (GLX::CONTEXT-TAG GL::CTX))
;          (XLIB:CARD32 GL::CAP)))
; --> LET UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> BLOCK SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN XLIB::WITH-BUFFER MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK XLIB::WITHOUT-ABORTS PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CHECK-PUT LET XLIB::CARD32-PUT 
; --> XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN FLUSH
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY
;                                 (XLIB:EXTENSION-OPCODE XLIB:DISPLAY "GLX"))
;       (XLIB::DATA GL::+FLUSH+)
;       (XLIB:CARD32 (GLX::CONTEXT-TAG GL::CTX)))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT LET XLIB::CARD32-PUT XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/gl.lisp
; in: DEFUN FINISH
;     (XLIB::WITH-BUFFER-REQUEST-AND-REPLY (XLIB:DISPLAY
;                                           (XLIB:EXTENSION-OPCODE XLIB:DISPLAY
;                                                                  "GLX")
;                                           NIL)
;         ((XLIB::DATA GL::+FINISH+) (XLIB:CARD32 (GLX::CONTEXT-TAG GL::CTX))))
; --> LET UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL 
; --> BLOCK SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN XLIB::WITH-BUFFER MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK XLIB::WITHOUT-ABORTS PROGN XLIB::WITH-BUFFER-REQUEST-INTERNAL 
; --> XLIB::WITH-BUFFER-OUTPUT LET LET* XLIB::CHECK-PUT LET XLIB::CARD32-PUT 
; --> XLIB::WRITE-CARD32 
; ==>
;   (XLIB::ASET-CARD32 (THE XLIB:CARD32 XLIB::.VALUE.) XLIB::BUFFER-BBUF
;                      (XLIB::INDEX+ XLIB::BUFFER-BOFFSET 4))
; 
; note: doing unsigned word to integer coercion (cost 20)
; 
; compilation unit finished
;   printed 338 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/xinerama.lisp
; in: DEFUN XINERAMA-QUERY-SCREENS
;     (XLIB.XINERAMA::MAKE-SCREEN-INFO :NUMBER NUMBER :X
;                                      (XLIB::INT16-GET XLIB.XINERAMA::INDEX) :Y
;                                      (XLIB::INT16-GET (+ XLIB.XINERAMA::INDEX 2))
;                                      :WIDTH
;                                      (XLIB::CARD16-GET
;                                       (+ XLIB.XINERAMA::INDEX 4))
;                                      :HEIGHT
;                                      (XLIB::CARD16-GET
;                                       (+ XLIB.XINERAMA::INDEX 6)))
; ==>
;   NUMBER
; 
; note: doing unsigned word to integer coercion (cost 20) from NUMBER

;     (INCF XLIB.XINERAMA::INDEX 8)
; --> LET* 
; ==>
;   (SETQ XLIB.XINERAMA::INDEX #:NEW264)
; 
; note: doing signed word to integer coercion (cost 20) to INDEX
; 
; compilation unit finished
;   printed 2 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/bezier.lisp
; in: DEFUN DRAW-CURVES
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::OPCODE :GC-FORCE XLIB:GCONTEXT)
;       ((XLIB::DATA XLIB:CARD8) 1)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::POINTS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::POINTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; compilation unit finished
;   printed 2 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/beziertest.lisp
; in: DEFUN BEZIER-TEST
;     (ZEROP COUNT)
; ==>
;   (= COUNT 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; compilation unit finished
;   printed 4 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/clipboard.lisp
; in: DEFUN MAIN
;     (XLIB:EVENT-CASE (CLIPBOARD::*DISPLAY*)
;       (:BUTTON-PRESS (CLIPBOARD::CODE TIME) (FORMAT T "~&ButtonPress~%")
;        (FINISH-OUTPUT)
;        (CASE CLIPBOARD::CODE
;          (1 (SETF #) (CLIPBOARD::OWNSELECT))
;          (2 (CLIPBOARD::ASK-PASTE))
;          (3 (CLIPBOARD::DESELECT))))
;       (:CLIENT-MESSAGE NIL (FORMAT T "~&ClientMessage~%") (FINISH-OUTPUT))
;       (:SELECTION-CLEAR (CLIPBOARD::SELECTION)
;        (FORMAT T "~&SelectionClear ~S~%" CLIPBOARD::SELECTION) (FINISH-OUTPUT))
;       (:SELECTION-NOTIFY
;        (CLIPBOARD::SELECTION CLIPBOARD::TARGET CLIPBOARD::PROPERTY)
;        (FORMAT T "~&SelectionNotify ~S ~S ~S~%" CLIPBOARD::SELECTION
;                CLIPBOARD::TARGET CLIPBOARD::PROPERTY)
;        (FINISH-OUTPUT)
;        (UNLESS (EQ CLIPBOARD::PROPERTY NIL)
;          (CLIPBOARD::RECV-PASTE CLIPBOARD::PROPERTY))
;        (XLIB:DISPLAY-FINISH-OUTPUT CLIPBOARD::*DISPLAY*))
;       (:SELECTION-REQUEST
;        (CLIPBOARD::SELECTION CLIPBOARD::TARGET CLIPBOARD::PROPERTY
;         CLIPBOARD::REQUESTOR TIME)
;        (FORMAT T "~&SelectionRequest ~S ~S ~S~%" CLIPBOARD::SELECTION
;                CLIPBOARD::TARGET CLIPBOARD::PROPERTY)
;        (FINISH-OUTPUT)
;        (CLIPBOARD::SEND-COPY CLIPBOARD::SELECTION CLIPBOARD::TARGET
;         CLIPBOARD::PROPERTY CLIPBOARD::REQUESTOR TIME)
;        (XLIB:DISPLAY-FINISH-OUTPUT CLIPBOARD::*DISPLAY*))
;       (:PROPERTY-NOTIFY (ATOM CLIPBOARD::STATE)
;        (FORMAT T "~&PropertyNotify ~S ~S~%" ATOM CLIPBOARD::STATE)
;        (FINISH-OUTPUT)))
; --> XLIB:EVENT-COND LET XLIB::EVENT-LOOP LET XLIB:WITH-EVENT-QUEUE MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION PROGV LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET UNWIND-PROTECT FLET 
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK SB-C::%WITHIN-CLEANUP 
; --> RETURN-FROM PROGN LET XLIB::EVENT-DISPATCH XLIB::READING-EVENT 
; --> XLIB::WITH-BUFFER-INPUT LET LET* LET CASE LET COND IF PROGN 
; --> XLIB::BINDING-EVENT-VALUES LET LET LET MACROLET IF ZEROP 
; ==>
;   (= #:G1846 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> XLIB:EVENT-COND LET XLIB::EVENT-LOOP LET XLIB:WITH-EVENT-QUEUE MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION PROGV LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET UNWIND-PROTECT FLET 
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK SB-C::%WITHIN-CLEANUP 
; --> RETURN-FROM PROGN LET XLIB::EVENT-DISPATCH XLIB::READING-EVENT 
; --> XLIB::WITH-BUFFER-INPUT LET LET* LET CASE LET COND IF COND IF COND IF 
; --> COND IF PROGN XLIB::BINDING-EVENT-VALUES LET LET LET MACROLET IF ZEROP 
; ==>
;   (= #:G5085 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; --> XLIB:EVENT-COND LET XLIB::EVENT-LOOP LET XLIB:WITH-EVENT-QUEUE MACROLET 
; --> LET XLIB::HOLDING-LOCK SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET 
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION PROGV LET 
; --> UNWIND-PROTECT FLET BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK 
; --> SB-C::%WITHIN-CLEANUP RETURN-FROM PROGN LOOP BLOCK TAGBODY PROGN 
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET UNWIND-PROTECT FLET 
; --> BLOCK MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL BLOCK SB-C::%WITHIN-CLEANUP 
; --> RETURN-FROM PROGN LET XLIB::EVENT-DISPATCH XLIB::READING-EVENT 
; --> XLIB::WITH-BUFFER-INPUT LET LET* LET CASE LET COND IF COND IF COND IF 
; --> COND IF COND IF PROGN XLIB::BINDING-EVENT-VALUES LET LET LET MACROLET IF 
; --> ZEROP 
; ==>
;   (= #:G4960 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

; ==>
;   (= #:G4959 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; compilation unit finished
;   printed 16 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/gl-test.lisp
; in: DEFUN GEAR
;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (COS XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63

;     (SIN XLIB:ANGLE)
; 
; note: unable to avoid inline argument range check
; because the argument range (SINGLE-FLOAT) was not within 2^63
; 
; compilation unit finished
;   printed 32 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/mandel.lisp
; in: DEFUN EVENT-LOOP
;     (XMANDEL::REPAINT-WINDOW XMANDEL::WINDOW XMANDEL::X XMANDEL::Y
;      (1- (+ XMANDEL::X XMANDEL::WIDTH)) (1- (+ XMANDEL::Y XMANDEL::HEIGHT)))
; 
; note: doing signed word to integer coercion (cost 20)
; 
; note: doing signed word to integer coercion (cost 20)
; 
; compilation unit finished
;   printed 2 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/menu.lisp
; in: DEFUN MENU-CHOOSE
;     (ZEROP COUNT)
; ==>
;   (= COUNT 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.

;     (ASSOC XLIB::EVENT-WINDOW XLIB::ITEMS)
; ==>
;   (SB-KERNEL:%ASSOC SB-C::ITEM LIST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   can't tell whether the first argument is a (OR FIXNUM (NOT NUMBER))

;     (POSITION XLIB:WINDOW XLIB::ITEMS :KEY #'FIRST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

;     (EQL XLIB::MW XLIB:WINDOW)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a SINGLE-FLOAT.
;   The second argument is a T, not a SINGLE-FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a T, not a DOUBLE-FLOAT.
;   The second argument is a T, not a DOUBLE-FLOAT.

;     (POSITION XLIB:WINDOW XLIB::ITEMS :KEY #'FIRST)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The second argument is a SEQUENCE, not a (OR CONS NULL VECTOR).

;     (EQL XLIB::MW XLIB:WINDOW)
; 
; note: forced to do GENERIC-EQL (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a T, not a FIXNUM.
;       The second argument is a T, not a FIXNUM.

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/menu.lisp
; in: DEFUN POP-UP
;     (ZEROP COUNT)
; ==>
;   (= COUNT 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; compilation unit finished
;   printed 14 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/demo/zoid.lisp
; in: DEFUN DRAW-FILLED-TRAPEZOIDS
;     (XLIB::WITH-BUFFER-REQUEST (XLIB:DISPLAY XLIB::OPCODE :GC-FORCE XLIB:GCONTEXT)
;       ((XLIB::DATA XLIB:CARD8) 1)
;       (XLIB:DRAWABLE XLIB:DRAWABLE)
;       (XLIB:GCONTEXT XLIB:GCONTEXT)
;       ((SEQUENCE :FORMAT XLIB:INT16) XLIB::POINTS))
; --> LET XLIB::WITH-BUFFER MACROLET LET XLIB::HOLDING-LOCK 
; --> SB-THREAD:WITH-RECURSIVE-LOCK SB-INT:DX-FLET FLET BLOCK 
; --> MULTIPLE-VALUE-PROG1 XLIB::WITHOUT-ABORTS PROGN 
; --> XLIB::WITH-BUFFER-REQUEST-INTERNAL XLIB::WITH-BUFFER-OUTPUT LET LET* 
; --> XLIB::CHECK-PUT XLIB::SEQUENCE-PUT LET 
; ==>
;   (LENGTH XLIB::POINTS)
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a (SIMPLE-ARRAY * (*)).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a SEQUENCE, not a VECTOR.
; 
; compilation unit finished
;   printed 2 notes

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/clx-20131003-git/test/trapezoid.lisp
; in: DEFUN ZOID-TEST
;     (ZEROP COUNT)
; ==>
;   (= COUNT 0)
; 
; note: unable to
;   open-code FLOAT to RATIONAL comparison
; due to type uncertainty:
;   The first argument is a NUMBER, not a FLOAT.
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX SINGLE-FLOAT).
; 
; note: unable to
;   optimize
; due to type uncertainty:
;   The first argument is a NUMBER, not a (COMPLEX DOUBLE-FLOAT).
; 
; note: unable to open code because: The operands might not be the same type.
; 
; compilation unit finished
;   printed 4 notes
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING: There is no class named XLIB::GCONTEXT-EXTENSION.
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING:
   unsupported DOCUMENTATION: type T for object of type SB-PCL::STRUCTURE-DIRECT-SLOT-DEFINITION
WARNING: There is no class named XMANDEL::QUEUE.
WARNING: There is no class named XMANDEL::OUT-QUEUE.
Error: The function XMANDEL::EMPTY-P is undefined.