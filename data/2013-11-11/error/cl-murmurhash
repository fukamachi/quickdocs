; in: QUICKDOCS.PARSER.UTIL:WITH-RETRYING 5
;     (LET ((#:RETRY-RECOMPILE983 5)
;           (#:RETRY-CONTINUE984 5)
;           (#:RETRY-LOAD-SYSTEM985 5))
;       (HANDLER-BIND ((ERROR (LAMBDA # #)) (ERROR (LAMBDA # #)))
;         (QUICKDOCS.PARSER:PARSE-DOCUMENTATION
;          (ASDF/SYSTEM:FIND-SYSTEM "cl-murmurhash"))))
; 
; caught STYLE-WARNING:
;   The variable #:RETRY-LOAD-SYSTEM985 is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/cl-murmurhash-20130720-git/cl-murmurhash.lisp
; in: DEFUN HASH32-OCTETS
;     (DEFUN CL-MURMURHASH::HASH32-OCTETS
;            (CL-MURMURHASH::VEC CL-MURMURHASH::SEED
;             &OPTIONAL (CL-MURMURHASH::LEN (LENGTH CL-MURMURHASH::VEC))
;             CL-MURMURHASH::MIX-ONLY)
;       (DECLARE (CL-MURMURHASH::INDEX CL-MURMURHASH::LEN)
;                (CL-MURMURHASH::OCTET-VECTOR CL-MURMURHASH::VEC))
;       (CL-MURMURHASH::HASH32-BODY AREF))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'CL-MURMURHASH::HASH32-OCTETS
;                    (SB-INT:NAMED-LAMBDA CL-MURMURHASH::HASH32-OCTETS
;                        (CL-MURMURHASH::VEC CL-MURMURHASH::SEED &OPTIONAL
;                         (CL-MURMURHASH::LEN (LENGTH CL-MURMURHASH::VEC))
;                         CL-MURMURHASH::MIX-ONLY)
;                      (DECLARE (CL-MURMURHASH::INDEX CL-MURMURHASH::LEN)
;                               (CL-MURMURHASH::OCTET-VECTOR CL-MURMURHASH::VEC))
;                      (BLOCK CL-MURMURHASH::HASH32-OCTETS
;                        (CL-MURMURHASH::HASH32-BODY AREF)))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing unsigned word to integer coercion (cost 20) from H1 to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/cl-murmurhash-20130720-git/cl-murmurhash.lisp
; in: DEFUN HASH32-INTEGER
;     (CL-MURMURHASH::HASH32-BODY CL-MURMURHASH::BYTE-REF)
; --> LET* LOGAND 
; ==>
;   (LOGAND (TRULY-THE #<SB-KERNEL:NUMERIC-TYPE UNSIGNED-BYTE> SB-C::Y)
;           4294967292)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 32).
;       etc.

; --> LET* UNLESS IF PROGN CL-MURMURHASH::^= LET* CL-MURMURHASH::^ BLOCK LDB 
; --> SB-KERNEL:%LDB LOGXOR 
; ==>
;   (LOGAND 'SB-C::DUMMY 4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 32).
;       etc.

; --> LET* 
; ==>
;   CL-MURMURHASH::H1
; 
; note: doing unsigned word to integer coercion (cost 20) from H1 to "<return value>"
; 
; note: doing unsigned word to integer coercion (cost 20) from H1 to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/cl-murmurhash-20130720-git/cl-murmurhash.lisp
; in: DEFUN HASH32-BASE-STRING
;     (DEFUN CL-MURMURHASH::HASH32-BASE-STRING
;            (CL-MURMURHASH::VEC CL-MURMURHASH::SEED
;             &OPTIONAL (CL-MURMURHASH::LEN (LENGTH CL-MURMURHASH::VEC))
;             CL-MURMURHASH::MIX-ONLY)
;       (DECLARE (CL-MURMURHASH::INDEX CL-MURMURHASH::LEN)
;                (SIMPLE-STRING CL-MURMURHASH::VEC))
;       (CL-MURMURHASH::HASH32-BODY CL-MURMURHASH::CHAR-REF))
; --> PROGN EVAL-WHEN 
; ==>
;   (SB-IMPL::%DEFUN 'CL-MURMURHASH::HASH32-BASE-STRING
;                    (SB-INT:NAMED-LAMBDA CL-MURMURHASH::HASH32-BASE-STRING
;                        (CL-MURMURHASH::VEC CL-MURMURHASH::SEED &OPTIONAL
;                         (CL-MURMURHASH::LEN (LENGTH CL-MURMURHASH::VEC))
;                         CL-MURMURHASH::MIX-ONLY)
;                      (DECLARE (CL-MURMURHASH::INDEX CL-MURMURHASH::LEN)
;                               (SIMPLE-STRING CL-MURMURHASH::VEC))
;                      (BLOCK CL-MURMURHASH::HASH32-BASE-STRING
;                        (CL-MURMURHASH::HASH32-BODY CL-MURMURHASH::CHAR-REF)))
;                    NIL 'NIL (SB-C:SOURCE-LOCATION))
; 
; note: doing unsigned word to integer coercion (cost 20) from H1 to "<return value>"

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/cl-murmurhash-20130720-git/cl-murmurhash.lisp
; in: DEFUN HASH128-OCTETS
;     (CL-MURMURHASH::HASH128-BODY AREF)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL IF <= 
; ==>
;   (INTEGER-LENGTH CL-MURMURHASH::SEED)
; 
; note: forced to do full call
;       unable to do inline (unsigned-byte 32) integer-length (cost 26) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL IF VALUES LDB SB-KERNEL:%LDB 
; --> LOGAND 
; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR LOGIOR 
; ==>
;   (ASH CL-MURMURHASH::H2 32)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 18446744069414584321) &OPTIONAL), not a (VALUES
;                                                                             FIXNUM
;                                                                             &REST
;                                                                             T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 18446744069414584321) &OPTIONAL), not a (VALUES
;                                                                             (UNSIGNED-BYTE
;                                                                              32)
;                                                                             &REST
;                                                                             T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The second argument is a (MOD 18446744069414584321), not a FIXNUM.
;       The result is a (VALUES (UNSIGNED-BYTE 64) &OPTIONAL), not a (VALUES
;                                                                     FIXNUM
;                                                                     &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a (SIGNED-BYTE 32).
;       The second argument is a (MOD 18446744069414584321), not a (SIGNED-BYTE
;                                                                   32).
;       The result is a (VALUES (UNSIGNED-BYTE 64) &OPTIONAL), not a (VALUES
;                                                                     (SIGNED-BYTE
;                                                                      32)
;                                                                     &REST T).
;       etc.

; ==>
;   (ASH CL-MURMURHASH::H3 64)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 79228162495817593519834398721) &OPTIONAL), not a (VALUES
;                                                                                      FIXNUM
;                                                                                      &REST
;                                                                                      T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 79228162495817593519834398721) &OPTIONAL), not a (VALUES
;                                                                                      (UNSIGNED-BYTE
;                                                                                       32)
;                                                                                      &REST
;                                                                                      T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR 
; ==>
;   (LOGIOR (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
;           (ASH CL-MURMURHASH::H3 64))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 64), not a FIXNUM.
;       The second argument is a (MOD 79228162495817593519834398721), not a FIXNUM.
;       The result is a (VALUES (UNSIGNED-BYTE 96) &OPTIONAL), not a (VALUES
;                                                                     FIXNUM
;                                                                     &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 64), not a (SIGNED-BYTE 32).
;       The second argument is a (MOD 79228162495817593519834398721), not a (SIGNED-BYTE
;                                                                            32).
;       The result is a (VALUES (UNSIGNED-BYTE 96) &OPTIONAL), not a (VALUES
;                                                                     (SIGNED-BYTE
;                                                                      32)
;                                                                     &REST T).
;       etc.

; ==>
;   (ASH CL-MURMURHASH::H4 96)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES
;                                                                (UNSIGNED-BYTE
;                                                                 32)
;                                                                &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; ==>
;   (LOGIOR
;    (LOGIOR (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
;            (ASH CL-MURMURHASH::H3 64))
;    (ASH CL-MURMURHASH::H4 96))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 96), not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 96), not a (SIGNED-BYTE 32).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 32).
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES
;                                                                (SIGNED-BYTE 32)
;                                                                &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H2
; 
; note: doing unsigned word to integer coercion (cost 20) from H2

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
; 
; note: doing unsigned word to integer coercion (cost 20) from H1, for:
;       the first argument of static-fun Two-arg-ior

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H3
; 
; note: doing unsigned word to integer coercion (cost 20) from H3

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H4
; 
; note: doing unsigned word to integer coercion (cost 20) from H4

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/cl-murmurhash-20130720-git/cl-murmurhash.lisp
; in: DEFUN HASH128-INTEGER
;     (CL-MURMURHASH::HASH128-BODY CL-MURMURHASH::BYTE-REF)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL IF <= 
; ==>
;   (INTEGER-LENGTH CL-MURMURHASH::SEED)
; 
; note: forced to do full call
;       unable to do inline (unsigned-byte 32) integer-length (cost 26) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL IF VALUES LDB SB-KERNEL:%LDB 
; --> LOGAND 
; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET LOGAND 
; ==>
;   (LOGAND (TRULY-THE #<SB-KERNEL:NUMERIC-TYPE INTEGER> SB-C::Y) 4294967280)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: forced to do GENERIC-< (cost 10)
;       unable to do inline fixnum comparison (cost 4) because:
;       The first argument is a (MOD 4294967311), not a FIXNUM.
;       The second argument is a (UNSIGNED-BYTE 32), not a FIXNUM.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY SB-LOOP::LOOP-REALLY-DESETQ SETQ THE 
; ==>
;   (+ CL-MURMURHASH::I 16)
; 
; note: forced to do GENERIC-+ (cost 10)
;       unable to do inline fixnum arithmetic (cost 1) because:
;       The first argument is a (MOD 4294967295), not a FIXNUM.
;       The result is a (VALUES (INTEGER 16 4294967310) &OPTIONAL), not a (VALUES
;                                                                          FIXNUM
;                                                                          &REST
;                                                                          T).
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (MOD 4294967295), not a FIXNUM.
;       The result is a (VALUES (INTEGER 16 4294967310) &OPTIONAL), not a (VALUES
;                                                                          FIXNUM
;                                                                          &REST
;                                                                          T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET UNLESS IF 
; --> PROGN CL-MURMURHASH::^= LET* CL-MURMURHASH::^ BLOCK LDB SB-KERNEL:%LDB 
; --> LOGXOR 
; ==>
;   (LOGAND 'SB-C::DUMMY 4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR LOGIOR 
; ==>
;   (ASH CL-MURMURHASH::H2 32)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 18446744069414584321) &OPTIONAL), not a (VALUES
;                                                                             FIXNUM
;                                                                             &REST
;                                                                             T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 18446744069414584321) &OPTIONAL), not a (VALUES
;                                                                             (UNSIGNED-BYTE
;                                                                              32)
;                                                                             &REST
;                                                                             T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The second argument is a (MOD 18446744069414584321), not a FIXNUM.
;       The result is a (VALUES (UNSIGNED-BYTE 64) &OPTIONAL), not a (VALUES
;                                                                     FIXNUM
;                                                                     &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a (SIGNED-BYTE 32).
;       The second argument is a (MOD 18446744069414584321), not a (SIGNED-BYTE
;                                                                   32).
;       The result is a (VALUES (UNSIGNED-BYTE 64) &OPTIONAL), not a (VALUES
;                                                                     (SIGNED-BYTE
;                                                                      32)
;                                                                     &REST T).
;       etc.

; ==>
;   (ASH CL-MURMURHASH::H3 64)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 79228162495817593519834398721) &OPTIONAL), not a (VALUES
;                                                                                      FIXNUM
;                                                                                      &REST
;                                                                                      T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 79228162495817593519834398721) &OPTIONAL), not a (VALUES
;                                                                                      (UNSIGNED-BYTE
;                                                                                       32)
;                                                                                      &REST
;                                                                                      T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR 
; ==>
;   (LOGIOR (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
;           (ASH CL-MURMURHASH::H3 64))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 64), not a FIXNUM.
;       The second argument is a (MOD 79228162495817593519834398721), not a FIXNUM.
;       The result is a (VALUES (UNSIGNED-BYTE 96) &OPTIONAL), not a (VALUES
;                                                                     FIXNUM
;                                                                     &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 64), not a (SIGNED-BYTE 32).
;       The second argument is a (MOD 79228162495817593519834398721), not a (SIGNED-BYTE
;                                                                            32).
;       The result is a (VALUES (UNSIGNED-BYTE 96) &OPTIONAL), not a (VALUES
;                                                                     (SIGNED-BYTE
;                                                                      32)
;                                                                     &REST T).
;       etc.

; ==>
;   (ASH CL-MURMURHASH::H4 96)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES
;                                                                (UNSIGNED-BYTE
;                                                                 32)
;                                                                &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; ==>
;   (LOGIOR
;    (LOGIOR (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
;            (ASH CL-MURMURHASH::H3 64))
;    (ASH CL-MURMURHASH::H4 96))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 96), not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 96), not a (SIGNED-BYTE 32).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 32).
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES
;                                                                (SIGNED-BYTE 32)
;                                                                &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ CL-MURMURHASH::I 1))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ CL-MURMURHASH::I 2))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ CL-MURMURHASH::I 3))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ CL-MURMURHASH::I 4))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 4) 1))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 4) 2))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 4) 3))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ CL-MURMURHASH::I 8))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 8) 1))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 8) 2))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 8) 3))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ CL-MURMURHASH::I 12))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 12) 1))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> LOGIOR ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 12) 2))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY LET CL-MURMURHASH::GETBLOCK LOGIOR LOGIOR 
; --> ASH 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+
;                             (CL-MURMURHASH::+ CL-MURMURHASH::I 12) 3))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOOP BLOCK 
; --> LET SB-LOOP::LOOP-BODY TAGBODY WHEN IF >= IF 
; ==>
;   (< SB-C::X SB-C::Y)
; 
; note: doing unsigned word to integer coercion (cost 20) from END, for:
;       the second argument of GENERIC-<

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ ASH CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 13 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 12 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ ASH CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 11 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 10 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 9 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 8 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ ASH CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 7 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 6 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 5 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 4 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ ASH CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 3 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 2 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 1 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 0 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20) from END

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H2
; 
; note: doing unsigned word to integer coercion (cost 20) from H2

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
; 
; note: doing unsigned word to integer coercion (cost 20) from H1, for:
;       the first argument of static-fun Two-arg-ior

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H3
; 
; note: doing unsigned word to integer coercion (cost 20) from H3

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H4
; 
; note: doing unsigned word to integer coercion (cost 20) from H4

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LET 
; --> MACROLET CL-MURMURHASH::SWITCH MACROLET TAGBODY CL-MURMURHASH::^= LET* 
; --> CL-MURMURHASH::^ ASH CL-MURMURHASH::TAIL 
; ==>
;   (CL-MURMURHASH::BYTE-REF CL-MURMURHASH::VEC
;                            (CL-MURMURHASH::+ 14 CL-MURMURHASH::END))
; 
; note: doing unsigned word to integer coercion (cost 20)

; file: /home/quickdocs_dev/quicklisp/dists/quicklisp/software/cl-murmurhash-20130720-git/cl-murmurhash.lisp
; in: DEFUN HASH128-BASE-STRING
;     (CL-MURMURHASH::HASH128-BODY CL-MURMURHASH::CHAR-REF)
; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL IF <= 
; ==>
;   (INTEGER-LENGTH CL-MURMURHASH::SEED)
; 
; note: forced to do full call
;       unable to do inline (unsigned-byte 32) integer-length (cost 26) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL IF VALUES LDB SB-KERNEL:%LDB 
; --> LOGAND 
; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; ==>
;   (ASH INT (- SB-C::POSN))
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a INTEGER, not a FIXNUM.
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES FIXNUM &REST T).
;       unable to do inline ASH (cost 3) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       The result is a (VALUES INTEGER &OPTIONAL), not a (VALUES
;                                                          (UNSIGNED-BYTE 32)
;                                                          &REST T).
;       etc.

; ==>
;   (LOGAND SB-C::X '4294967295)
; 
; note: forced to do static-fun Two-arg-and (cost 53)
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (UNSIGNED-BYTE 32).
;       unable to do inline (unsigned-byte 32) arithmetic (cost 2) because:
;       The first argument is a INTEGER, not a (SIGNED-BYTE 32).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR LOGIOR 
; ==>
;   (ASH CL-MURMURHASH::H2 32)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 18446744069414584321) &OPTIONAL), not a (VALUES
;                                                                             FIXNUM
;                                                                             &REST
;                                                                             T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 18446744069414584321) &OPTIONAL), not a (VALUES
;                                                                             (UNSIGNED-BYTE
;                                                                              32)
;                                                                             &REST
;                                                                             T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The second argument is a (MOD 18446744069414584321), not a FIXNUM.
;       The result is a (VALUES (UNSIGNED-BYTE 64) &OPTIONAL), not a (VALUES
;                                                                     FIXNUM
;                                                                     &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a (SIGNED-BYTE 32).
;       The second argument is a (MOD 18446744069414584321), not a (SIGNED-BYTE
;                                                                   32).
;       The result is a (VALUES (UNSIGNED-BYTE 64) &OPTIONAL), not a (VALUES
;                                                                     (SIGNED-BYTE
;                                                                      32)
;                                                                     &REST T).
;       etc.

; ==>
;   (ASH CL-MURMURHASH::H3 64)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES (MOD 79228162495817593519834398721) &OPTIONAL), not a (VALUES
;                                                                                      FIXNUM
;                                                                                      &REST
;                                                                                      T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES (MOD 79228162495817593519834398721) &OPTIONAL), not a (VALUES
;                                                                                      (UNSIGNED-BYTE
;                                                                                       32)
;                                                                                      &REST
;                                                                                      T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR 
; ==>
;   (LOGIOR (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
;           (ASH CL-MURMURHASH::H3 64))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 64), not a FIXNUM.
;       The second argument is a (MOD 79228162495817593519834398721), not a FIXNUM.
;       The result is a (VALUES (UNSIGNED-BYTE 96) &OPTIONAL), not a (VALUES
;                                                                     FIXNUM
;                                                                     &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 64), not a (SIGNED-BYTE 32).
;       The second argument is a (MOD 79228162495817593519834398721), not a (SIGNED-BYTE
;                                                                            32).
;       The result is a (VALUES (UNSIGNED-BYTE 96) &OPTIONAL), not a (VALUES
;                                                                     (SIGNED-BYTE
;                                                                      32)
;                                                                     &REST T).
;       etc.

; ==>
;   (ASH CL-MURMURHASH::H4 96)
; 
; note: forced to do full call
;       unable to do inline ASH (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 32), not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline ASH (cost 3) because:
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES
;                                                                (UNSIGNED-BYTE
;                                                                 32)
;                                                                &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; ==>
;   (LOGIOR
;    (LOGIOR (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
;            (ASH CL-MURMURHASH::H3 64))
;    (ASH CL-MURMURHASH::H4 96))
; 
; note: forced to do static-fun Two-arg-ior (cost 53)
;       unable to do inline fixnum arithmetic (cost 2) because:
;       The first argument is a (UNSIGNED-BYTE 96), not a FIXNUM.
;       The second argument is a UNSIGNED-BYTE, not a FIXNUM.
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES FIXNUM
;                                                                       &REST T).
;       unable to do inline (signed-byte 32) arithmetic (cost 3) because:
;       The first argument is a (UNSIGNED-BYTE 96), not a (SIGNED-BYTE 32).
;       The second argument is a UNSIGNED-BYTE, not a (SIGNED-BYTE 32).
;       The result is a (VALUES UNSIGNED-BYTE &OPTIONAL), not a (VALUES
;                                                                (SIGNED-BYTE 32)
;                                                                &REST T).
;       etc.

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H2
; 
; note: doing unsigned word to integer coercion (cost 20) from H2

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR 
; ==>
;   (LOGIOR CL-MURMURHASH::H1 (ASH CL-MURMURHASH::H2 32))
; 
; note: doing unsigned word to integer coercion (cost 20) from H1, for:
;       the first argument of static-fun Two-arg-ior

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H3
; 
; note: doing unsigned word to integer coercion (cost 20) from H3

; --> MULTIPLE-VALUE-BIND MULTIPLE-VALUE-CALL FUNCTION LET MACROLET LOGIOR 
; --> LOGIOR ASH 
; ==>
;   CL-MURMURHASH::H4
; 
; note: doing unsigned word to integer coercion (cost 20) from H4
; 
; compilation unit finished
;   printed 98 notes
Error: #<BUILT-IN-CLASS SB-KERNEL::SIMPLE-ARRAY-UNSIGNED-BYTE-8> is not a legal class name.